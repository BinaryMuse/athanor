---
phase: 02-run-page-log-display
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/athanor_web/lib/athanor_web/live/experiments/components/log_panel.ex
  - apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex
  - apps/athanor_web/assets/js/app.js
autonomous: true

must_haves:
  truths:
    - "Log panel displays new entries as they arrive in real-time"
    - "Page remains responsive with 10,000+ log entries (DOM capped at 1000 nodes)"
    - "Auto-scroll follows new entries when user is at bottom"
    - "User can scroll up through log history without being jumped back to bottom"
    - "Log levels (debug/info/warn/error) are visually distinct with semantic badges"
  artifacts:
    - path: "apps/athanor_web/lib/athanor_web/live/experiments/components/log_panel.ex"
      provides: "LogPanel Phoenix.Component for log rendering"
      exports: ["log_panel/1"]
    - path: "apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex"
      provides: "Bounded stream with limit on mount and insert"
      contains: "stream_insert.*limit:"
    - path: "apps/athanor_web/assets/js/app.js"
      provides: "AutoScroll hook with near-bottom detection"
      contains: "isNearBottom"
  key_links:
    - from: "apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex"
      to: "apps/athanor_web/lib/athanor_web/live/experiments/components/log_panel.ex"
      via: "import and function call"
      pattern: "LogPanel\\.log_panel"
    - from: "apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex"
      to: "stream/4 and stream_insert/4"
      via: "limit: -@log_stream_limit on both"
      pattern: "limit:\\s*-@log_stream_limit"
    - from: "apps/athanor_web/assets/js/app.js"
      to: "DOM logs-container element"
      via: "phx-hook=\"AutoScroll\" with near-bottom check"
      pattern: "isNearBottom.*scrollToBottom"
---

<objective>
Implement bounded log streaming for the run page to handle high-volume experiment output without browser performance degradation.

Purpose: The current implementation loads all logs into DOM without limit, causing performance issues with 10,000+ entries. Stream limits enable the DOM to stay bounded while still showing real-time log updates.

Output: LogPanel component with bounded stream (1000 DOM nodes max), refined AutoScroll hook that respects user scroll position.
</objective>

<execution_context>
@/Users/binarymuse/.claude/get-shit-done/workflows/execute-plan.md
@/Users/binarymuse/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-visual-identity-and-theme-foundation/DESIGN-TOKENS.md
@.planning/phases/02-run-page-log-display/02-RESEARCH.md
@apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex
@apps/athanor_web/lib/athanor_web/live/experiments/components/status_badge.ex
@apps/athanor_web/assets/js/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract LogPanel component and wire bounded streams</name>
  <files>
    apps/athanor_web/lib/athanor_web/live/experiments/components/log_panel.ex
    apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex
  </files>
  <action>
Create `LogPanel` Phoenix.Component following the existing `StatusBadge` pattern:

**log_panel.ex:**
- Module: `AthanorWeb.Experiments.Components.LogPanel`
- `use Phoenix.Component`
- Attributes: `streams` (map, required), `auto_scroll` (boolean, required), `log_count` (integer, required)
- Function: `log_panel/1` renders the log card with:
  - Card wrapper: `bg-base-200 rounded-box`
  - Header row with "Logs" title and auto-scroll toggle (checkbox with `phx-click="toggle_auto_scroll"`)
  - Log container: `id="logs-container"`, `phx-hook="AutoScroll"`, `data-auto-scroll={to_string(@auto_scroll)}`, `bg-base-300 rounded-box p-3 h-96 overflow-y-auto font-mono text-xs`
  - Empty state when `@log_count == 0`: "No logs yet" with `text-base-content/40` (tertiary per DESIGN-TOKENS.md)
  - Stream container: `id="logs" phx-update="stream" class="space-y-1"`
  - Log row rendering with:
    - Timestamp: `text-base-content/40` (tertiary)
    - Level badge: `badge badge-{error|warning|info|ghost} badge-xs mx-1`
    - Message: `text-base-content`
    - Metadata (if present): `text-base-content/40`
  - Row-level coloring: `text-error` for error level, `text-warning` for warn level

**show.ex modifications:**
- Add module attribute: `@log_stream_limit 1_000`
- Add alias: `alias AthanorWeb.Experiments.Components.LogPanel`
- In `mount/3`:
  - Change `logs = Experiments.list_logs(run)` to `logs = Experiments.list_logs(run, limit: @log_stream_limit)`
  - Change `stream(:logs, logs)` to `stream(:logs, logs, limit: -@log_stream_limit)`
- In `handle_info({:log_added, log}, socket)`:
  - Change `stream_insert(:logs, log)` to `stream_insert(:logs, log, limit: -@log_stream_limit)`
- In `handle_info({:logs_added, _count}, socket)`:
  - Change `logs = Experiments.list_logs(socket.assigns.run)` to `logs = Experiments.list_logs(socket.assigns.run, limit: @log_stream_limit)`
  - Change `stream(:logs, logs, reset: true)` to `stream(:logs, logs, reset: true, limit: -@log_stream_limit)`
- In `render/1`:
  - Replace the entire log card `<div class="card bg-base-200">...</div>` (lines 79-117) with: `<LogPanel.log_panel streams={@streams} auto_scroll={@auto_scroll} log_count={@log_count} />`
- Remove the now-unused private functions: `log_class/1`, `level_badge/1`, `format_timestamp/1` (move to LogPanel if not already there)

**Color compliance (DESIGN-TOKENS.md):**
- Change `/50` opacity to `/40` for timestamps and metadata (tertiary text)
- Keep `/60` for secondary labels if any
  </action>
  <verify>
Run `mix compile` - no errors or warnings. Manually verify log panel renders by visiting a run page (e.g., start a test experiment). Check that log entries appear with correct styling.
  </verify>
  <done>
LogPanel component exists and is used by RunLive.Show. Stream operations include `limit: -1000` on both initial stream and inserts. DB queries use `limit: 1000`. Colors follow DESIGN-TOKENS.md conventions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refine AutoScroll hook with near-bottom detection</name>
  <files>
    apps/athanor_web/assets/js/app.js
  </files>
  <action>
Update the `AutoScroll` hook in `assets/js/app.js` to avoid jumping users back to bottom when they have scrolled up to read history.

**Current behavior (problematic):**
- MutationObserver fires on every DOM change
- If `data-auto-scroll="true"`, immediately scrolls to bottom
- User cannot scroll up to read history without being jumped back

**New behavior:**
- MutationObserver still fires on DOM changes
- Only scroll to bottom if:
  1. `data-auto-scroll="true"` AND
  2. User is already near the bottom (within 100px threshold)
- When user explicitly toggles auto-scroll ON (via `updated()` callback), always jump to bottom

**Implementation:**

```javascript
AutoScroll: {
  mounted() {
    this.scrollToBottom()
    this.observer = new MutationObserver(() => {
      if (this.el.dataset.autoScroll === "true" && this.isNearBottom()) {
        this.scrollToBottom()
      }
    })
    this.observer.observe(this.el, { childList: true, subtree: true })
  },
  updated() {
    // Called when data-auto-scroll attribute changes via server push
    // If user just enabled auto-scroll, jump to bottom immediately
    if (this.el.dataset.autoScroll === "true") {
      this.scrollToBottom()
    }
  },
  destroyed() {
    if (this.observer) {
      this.observer.disconnect()
    }
  },
  isNearBottom() {
    const threshold = 100 // pixels from bottom
    return this.el.scrollHeight - this.el.scrollTop - this.el.clientHeight <= threshold
  },
  scrollToBottom() {
    this.el.scrollTop = this.el.scrollHeight
  }
}
```

The key change is adding `isNearBottom()` check in the MutationObserver callback. The `updated()` callback continues to scroll immediately when auto-scroll is re-enabled (user toggled the checkbox).
  </action>
  <verify>
Manual test: Open a run page with active logging. Scroll up in the log panel. Verify new logs do NOT jump you back to bottom. Toggle auto-scroll off then on - verify it DOES jump to bottom. Verify when at bottom, new logs continue to scroll view down.
  </verify>
  <done>
AutoScroll hook includes `isNearBottom()` function with 100px threshold. MutationObserver only triggers scroll when user is near bottom. Toggle still works to jump to bottom when re-enabled.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Compile check:** `mix compile` passes with no warnings
2. **Stream limit verification:** grep for `limit:.*-@log_stream_limit` in show.ex - should appear 3 times (mount stream, log_added insert, logs_added reset)
3. **DB limit verification:** grep for `list_logs.*limit:` in show.ex - should appear 2 times (mount, batch handler)
4. **Component integration:** LogPanel.log_panel call appears in show.ex render function
5. **Hook verification:** `isNearBottom` function exists in app.js AutoScroll hook
6. **Manual test:** Start an experiment that produces logs. Page should remain responsive. Auto-scroll should respect user position.
</verification>

<success_criteria>
- [ ] LogPanel component extracted and renders log entries with semantic styling
- [ ] RunLive.Show uses `limit: -1000` on all stream operations
- [ ] RunLive.Show uses `limit: 1000` on all DB queries for logs
- [ ] AutoScroll hook only auto-scrolls when user is near bottom
- [ ] Log levels display with correct badge colors (error, warning, info, debug)
- [ ] Colors comply with DESIGN-TOKENS.md (no `/50` opacity, use `/40` for tertiary)
- [ ] No compile warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-run-page-log-display/02-01-SUMMARY.md`
</output>
