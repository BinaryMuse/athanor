---
phase: 02-run-page-log-display
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/athanor/lib/athanor/runtime/run_buffer.ex (new)
  - apps/athanor/lib/athanor/runtime/run_supervisor.ex
  - apps/athanor/lib/athanor/runtime/run_server.ex
  - apps/athanor/lib/athanor/runtime/run_context.ex
  - apps/athanor/lib/athanor/runtime.ex
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "UI remains responsive during rapid log emission (100+ logs/second)"
    - "Experiment code writes to ETS (no mailbox congestion)"
    - "Logs, results, and progress are flushed every 100ms"
    - "Run completion triggers synchronous final flush"
  artifacts:
    - path: "apps/athanor/lib/athanor/runtime/run_buffer.ex"
      provides: "GenServer owning ETS tables with periodic flush"
      contains: "defmodule Athanor.Runtime.RunBuffer"
    - path: "apps/athanor/lib/athanor/runtime.ex"
      provides: "Runtime API writing to ETS via RunBuffer"
      contains: ":ets.insert"
  key_links:
    - from: "apps/athanor/lib/athanor/runtime.ex"
      to: "apps/athanor/lib/athanor/runtime/run_buffer.ex"
      via: "ETS table writes + flush_sync call"
      pattern: ":ets.insert.*run_buffer"
    - from: "apps/athanor/lib/athanor/runtime/run_buffer.ex"
      to: "apps/athanor/lib/athanor/experiments/broadcasts.ex"
      via: "Batched broadcasts on flush"
      pattern: "Broadcasts.logs_added|Broadcasts.progress_updated"
---

<objective>
Implement producer-side batching via ETS tables to eliminate LiveView mailbox congestion. The RunBuffer GenServer owns per-run ETS tables; experiment code writes directly to ETS (instant, no message passing); RunBuffer flushes periodically to DB and broadcasts batched events.

Purpose: Human testing revealed the UI becomes unresponsive during rapid log emission because each log generates a PubSub message that floods the LiveView mailbox. Consumer-side batching was insufficient - the fix must be at the producer level.

Output: RunBuffer GenServer with ETS-based buffering, updated Runtime API, proper supervision integration.
</objective>

<execution_context>
@/Users/binarymuse/.claude/get-shit-done/workflows/execute-plan.md
@/Users/binarymuse/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/PITFALLS.md (Pitfall 2: Per-Log PubSub Message Flooding)
@apps/athanor/lib/athanor/runtime.ex
@apps/athanor/lib/athanor/runtime/run_server.ex
@apps/athanor/lib/athanor/runtime/run_supervisor.ex
@apps/athanor/lib/athanor/runtime/run_context.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RunBuffer GenServer with ETS table management</name>
  <files>
    apps/athanor/lib/athanor/runtime/run_buffer.ex (new)
  </files>
  <action>
Create a new GenServer that owns ETS tables for buffering logs, results, and progress.

**File: `apps/athanor/lib/athanor/runtime/run_buffer.ex`**

```elixir
defmodule Athanor.Runtime.RunBuffer do
  @moduledoc """
  ETS-based buffer for experiment output.

  Owns three ETS tables per run:
  - Logs: ordered_set, append-only, batch inserted on flush
  - Results: ordered_set, append-only, batch inserted on flush
  - Progress: set with single :current key, broadcasts latest on flush

  Flushes every 100ms to DB and broadcasts batched events.
  """

  use GenServer

  alias Athanor.Experiments
  alias Athanor.Experiments.Broadcasts

  @flush_interval_ms 100

  defstruct [:run_id, :run, :logs_table, :results_table, :progress_table]

  # --- Client API ---

  def start_link(args) do
    run = Keyword.fetch!(args, :run)
    GenServer.start_link(__MODULE__, args,
      name: {:via, Registry, {Athanor.Runtime.RunBufferRegistry, run.id}}
    )
  end

  @doc """
  Get the ETS table names for a run. Used by Runtime module for direct writes.
  """
  def table_names(run_id) do
    %{
      logs: :"run_#{run_id}_logs",
      results: :"run_#{run_id}_results",
      progress: :"run_#{run_id}_progress"
    }
  end

  @doc """
  Synchronously flush all pending data. Called before run completion.
  """
  def flush_sync(run_id) do
    case Registry.lookup(Athanor.Runtime.RunBufferRegistry, run_id) do
      [{pid, _}] -> GenServer.call(pid, :flush_sync, 30_000)
      [] -> :ok
    end
  end

  # --- Server Callbacks ---

  @impl true
  def init(args) do
    run = Keyword.fetch!(args, :run)
    tables = table_names(run.id)

    # Create ETS tables - public so Runtime can write directly
    logs_table = :ets.new(tables.logs, [:ordered_set, :public, :named_table])
    results_table = :ets.new(tables.results, [:ordered_set, :public, :named_table])
    progress_table = :ets.new(tables.progress, [:set, :public, :named_table])

    state = %__MODULE__{
      run_id: run.id,
      run: run,
      logs_table: logs_table,
      results_table: results_table,
      progress_table: progress_table
    }

    schedule_flush()
    {:ok, state}
  end

  @impl true
  def handle_call(:flush_sync, _from, state) do
    do_flush(state)
    {:reply, :ok, state}
  end

  @impl true
  def handle_info(:flush, state) do
    do_flush(state)
    schedule_flush()
    {:noreply, state}
  end

  @impl true
  def terminate(_reason, state) do
    # Final flush on shutdown
    do_flush(state)

    # Clean up ETS tables
    safe_delete_table(state.logs_table)
    safe_delete_table(state.results_table)
    safe_delete_table(state.progress_table)

    :ok
  end

  # --- Private ---

  defp schedule_flush do
    Process.send_after(self(), :flush, @flush_interval_ms)
  end

  defp do_flush(state) do
    flush_logs(state)
    flush_results(state)
    flush_progress(state)
  end

  defp flush_logs(state) do
    entries = :ets.tab2list(state.logs_table)
    :ets.delete_all_objects(state.logs_table)

    if entries != [] do
      # entries are {mono_time, log_data} tuples, sorted by time
      log_entries = Enum.map(entries, fn {_key, data} -> data end)
      {count, _} = Experiments.create_logs(state.run, log_entries)
      Broadcasts.logs_added(state.run_id, count)
    end
  end

  defp flush_results(state) do
    entries = :ets.tab2list(state.results_table)
    :ets.delete_all_objects(state.results_table)

    # Insert results one by one (they have unique keys)
    Enum.each(entries, fn {_mono_time, %{key: key, value: value}} ->
      case Experiments.create_result(state.run, key, value) do
        {:ok, result} -> Broadcasts.result_added(state.run_id, result)
        _ -> :ok
      end
    end)
  end

  defp flush_progress(state) do
    case :ets.lookup(state.progress_table, :current) do
      [{:current, progress}] ->
        :ets.delete_all_objects(state.progress_table)
        Broadcasts.progress_updated(state.run_id, progress)
      [] ->
        :ok
    end
  end

  defp safe_delete_table(table) do
    try do
      :ets.delete(table)
    rescue
      ArgumentError -> :ok
    end
  end
end
```

**Result:** RunBuffer GenServer that owns ETS tables and flushes every 100ms. Tables are public so Runtime can write directly without message passing.
  </action>
  <verify>
1. File compiles with `mix compile`
2. Module defines start_link, table_names, flush_sync
3. ETS tables created with correct types (ordered_set for logs/results, set for progress)
4. Flush logic handles all three data types
  </verify>
  <done>
RunBuffer GenServer created with ETS table management and periodic flushing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add RunBufferRegistry and update supervision tree</name>
  <files>
    apps/athanor/lib/athanor/application.ex
    apps/athanor/lib/athanor/runtime/run_supervisor.ex
  </files>
  <action>
Add a Registry for RunBuffer processes and update RunSupervisor to start RunBuffer alongside RunServer.

**Update `apps/athanor/lib/athanor/application.ex`:**

Add RunBufferRegistry to the children list, after RunRegistry:

```elixir
{Registry, keys: :unique, name: Athanor.Runtime.RunBufferRegistry},
```

**Update `apps/athanor/lib/athanor/runtime/run_supervisor.ex`:**

Modify `start_run/2` to start both RunServer and RunBuffer. We need to start RunBuffer first so tables exist before experiment runs.

```elixir
def start_run(run, opts \\ []) do
  # Start buffer first - creates ETS tables
  buffer_spec = {Athanor.Runtime.RunBuffer, [run: run]}
  {:ok, _buffer_pid} = DynamicSupervisor.start_child(__MODULE__, buffer_spec)

  # Then start server - experiment can now write to tables
  server_spec = {RunServer, [run: run, opts: opts]}
  DynamicSupervisor.start_child(__MODULE__, server_spec)
end
```

Also add a function to stop the buffer when the run ends. Update or add:

```elixir
def stop_buffer(run_id) do
  case Registry.lookup(Athanor.Runtime.RunBufferRegistry, run_id) do
    [{pid, _}] ->
      # flush_sync is called in terminate, so just stop
      DynamicSupervisor.terminate_child(__MODULE__, pid)
    [] ->
      :ok
  end
end
```

**Result:** RunBuffer is started before RunServer for each run, ensuring ETS tables exist when experiment code begins.
  </action>
  <verify>
1. `mix compile` passes
2. Application starts without errors
3. Registry listed in application.ex children
4. start_run creates both buffer and server
  </verify>
  <done>
RunBufferRegistry added to application supervision tree. RunSupervisor starts RunBuffer before RunServer for each run.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Runtime API to write to ETS</name>
  <files>
    apps/athanor/lib/athanor/runtime.ex
  </files>
  <action>
Modify Runtime.log/4, Runtime.result/3, and Runtime.progress/4 to write directly to ETS tables instead of immediately persisting and broadcasting.

**Update `apps/athanor/lib/athanor/runtime.ex`:**

Add alias at top:
```elixir
alias Athanor.Runtime.RunBuffer
```

**Replace `log/4`:**

```elixir
def log(%RunContext{} = ctx, level, message, metadata \\ nil)
    when level in [:debug, :info, :warn, :error] do
  tables = RunBuffer.table_names(ctx.run.id)
  key = System.monotonic_time(:nanosecond)

  entry = %{
    level: to_string(level),
    message: message,
    metadata: metadata,
    inserted_at: DateTime.utc_now()
  }

  :ets.insert(tables.logs, {key, entry})
  :ok
end
```

**Keep `log_batch/2` but update it:**

```elixir
def log_batch(%RunContext{} = ctx, entries) when is_list(entries) do
  tables = RunBuffer.table_names(ctx.run.id)
  now = DateTime.utc_now()

  ets_entries =
    entries
    |> Enum.with_index()
    |> Enum.map(fn {{level, message, metadata}, idx} ->
      key = System.monotonic_time(:nanosecond) + idx
      {key, %{
        level: to_string(level),
        message: message,
        metadata: metadata,
        inserted_at: now
      }}
    end)

  :ets.insert(tables.logs, ets_entries)
  :ok
end
```

**Replace `result/3`:**

```elixir
def result(%RunContext{} = ctx, key, value) when is_binary(key) do
  tables = RunBuffer.table_names(ctx.run.id)
  mono_key = System.monotonic_time(:nanosecond)
  value = if is_map(value), do: value, else: %{value: value}

  :ets.insert(tables.results, {mono_key, %{key: key, value: value}})
  :ok
end
```

**Replace `progress/4`:**

```elixir
def progress(%RunContext{} = ctx, current, total, message \\ nil)
    when is_integer(current) and is_integer(total) do
  tables = RunBuffer.table_names(ctx.run.id)

  progress = %{
    current: current,
    total: total,
    percent: if(total > 0, do: round(current / total * 100), else: 0),
    message: message,
    updated_at: DateTime.utc_now()
  }

  # Single key - always overwrites previous
  :ets.insert(tables.progress, {:current, progress})
  :ok
end
```

**Result:** All Runtime write operations now go to ETS tables. No immediate DB writes or PubSub broadcasts. RunBuffer handles batched persistence.
  </action>
  <verify>
1. `mix compile` passes with no warnings
2. Runtime.log writes to ETS, not DB
3. Runtime.result writes to ETS, not DB
4. Runtime.progress writes to ETS, not immediate broadcast
  </verify>
  <done>
Runtime API updated to write directly to ETS tables. No message passing, no immediate broadcasts.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update completion flow to flush synchronously</name>
  <files>
    apps/athanor/lib/athanor/runtime.ex
    apps/athanor/lib/athanor/runtime/run_server.ex
  </files>
  <action>
Ensure all pending data is flushed before a run is marked complete.

**Update `Runtime.complete/1`:**

```elixir
def complete(%RunContext{} = ctx) do
  # Flush all pending data before marking complete
  RunBuffer.flush_sync(ctx.run.id)

  case Experiments.complete_run(ctx.run) do
    {:ok, run} ->
      Broadcasts.run_completed(run)
      {:ok, run}

    error ->
      error
  end
end
```

**Update `Runtime.fail/2`:**

```elixir
def fail(%RunContext{} = ctx, error) when is_binary(error) do
  # Flush pending data even on failure
  RunBuffer.flush_sync(ctx.run.id)

  case Experiments.fail_run(ctx.run, error) do
    {:ok, run} ->
      Broadcasts.run_completed(run)
      {:ok, run}

    error ->
      error
  end
end
```

**Update `RunServer` completion helpers:**

In `run_server.ex`, update `complete_run/1`, `fail_run/2`, and `cancel_run/1` to also call flush_sync:

```elixir
defp complete_run(ctx) do
  alias Athanor.Experiments.Broadcasts
  alias Athanor.Runtime.RunBuffer

  RunBuffer.flush_sync(ctx.run.id)
  {:ok, run} = Experiments.complete_run(ctx.run)
  Broadcasts.run_completed(run)
end

defp fail_run(ctx, error) do
  alias Athanor.Experiments.Broadcasts
  alias Athanor.Runtime.RunBuffer

  RunBuffer.flush_sync(ctx.run.id)
  {:ok, run} = Experiments.fail_run(ctx.run, error)
  Broadcasts.run_completed(run)
end

defp cancel_run(ctx) do
  alias Athanor.Experiments.Broadcasts
  alias Athanor.Runtime.RunBuffer

  RunBuffer.flush_sync(ctx.run.id)
  {:ok, run} = Experiments.cancel_run(ctx.run)
  Broadcasts.run_completed(run)
end
```

**Result:** Run completion always flushes pending data first. No logs/results lost on completion.
  </action>
  <verify>
1. `mix compile` passes
2. Runtime.complete calls RunBuffer.flush_sync before Experiments.complete_run
3. Runtime.fail calls RunBuffer.flush_sync before Experiments.fail_run
4. RunServer helpers also call flush_sync
  </verify>
  <done>
Completion flow updated to synchronously flush all pending data before marking run complete.
  </done>
</task>

<task type="auto">
  <name>Task 5: Clean up RunBuffer on run termination</name>
  <files>
    apps/athanor/lib/athanor/runtime/run_server.ex
  </files>
  <action>
Ensure RunBuffer is properly terminated when RunServer stops.

**Update `RunServer.handle_info/2` for task completion:**

After the run completes (in the `{ref, result}` handler), stop the buffer:

```elixir
@impl true
def handle_info({ref, result}, %{task_ref: ref} = state) do
  Process.demonitor(ref, [:flush])

  case result do
    :ok ->
      :ok

    {:ok, _} ->
      ensure_completed(state.ctx)

    {:error, error} ->
      fail_run(state.ctx, error)

    {:cancelled, _} ->
      cancel_run(state.ctx)

    other ->
      Experiments.create_log(
        state.ctx.run,
        "warn",
        "Unexpected return value: #{inspect(other)}"
      )
      ensure_completed(state.ctx)
  end

  # Stop the buffer (flushes in terminate/2)
  Athanor.Runtime.RunSupervisor.stop_buffer(state.ctx.run.id)

  {:stop, :normal, state}
end
```

Also handle the DOWN message:

```elixir
@impl true
def handle_info({:DOWN, ref, :process, _pid, reason}, %{task_ref: ref} = state) do
  error = "Experiment crashed: #{inspect(reason)}"
  fail_run(state.ctx, error)

  # Stop the buffer
  Athanor.Runtime.RunSupervisor.stop_buffer(state.ctx.run.id)

  {:stop, :normal, state}
end
```

**Result:** RunBuffer is explicitly stopped after run completion, ensuring final flush and ETS table cleanup.
  </action>
  <verify>
1. `mix compile` passes
2. RunServer stops buffer after task completes
3. RunServer stops buffer after task crashes
  </verify>
  <done>
RunBuffer cleanup added to RunServer termination flow.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Compile check:** `mix compile` passes with no warnings
2. **Application start:** `iex -S mix` starts without errors
3. **Table creation:** Run an experiment, verify ETS tables exist with `:ets.info(:"run_#{id}_logs")`
4. **Buffering:** Add IO.inspect in flush_logs to confirm batching occurs
5. **Manual stress test:** Run experiment with 1000+ logs rapidly:
   - UI should remain responsive throughout
   - Logs should appear in batches (not one-by-one)
   - Progress bar should update smoothly
   - Run completion should show all logs (no data loss)
6. **Completion flush:** Verify final logs appear immediately when run completes (not delayed)
</verification>

<success_criteria>
- [ ] RunBuffer GenServer created with ETS table ownership
- [ ] RunBufferRegistry added to application supervision
- [ ] RunSupervisor starts RunBuffer before RunServer
- [ ] Runtime.log/4 writes to ETS (no DB, no broadcast)
- [ ] Runtime.result/3 writes to ETS (no DB, no broadcast)
- [ ] Runtime.progress/4 writes to ETS (no broadcast)
- [ ] RunBuffer flushes every 100ms to DB + broadcasts
- [ ] Runtime.complete/1 triggers synchronous flush
- [ ] RunServer cleans up RunBuffer on termination
- [ ] UI remains responsive during 100+ logs/second
- [ ] No data loss on run completion
</success_criteria>

<output>
After completion, create `.planning/phases/02-run-page-log-display/02-02-SUMMARY.md`
</output>
