---
phase: 02-run-page-log-display
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex
  - apps/athanor_web/assets/js/app.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "UI remains responsive during rapid log emission (100+ logs/second)"
    - "Auto-scroll checkbox unchecks when user scrolls away from bottom"
    - "Auto-scroll toggle responds immediately even during high-volume streaming"
  artifacts:
    - path: "apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex"
      provides: "Consumer-side log batching with send_after coalescing"
      contains: "Process.send_after.*:flush_pending_logs"
    - path: "apps/athanor_web/assets/js/app.js"
      provides: "Scroll position event pushing from AutoScroll hook"
      contains: "pushEvent.*scroll_position"
  key_links:
    - from: "apps/athanor_web/assets/js/app.js"
      to: "apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex"
      via: "pushEvent for scroll position"
      pattern: "pushEvent.*scroll_position.*handle_event.*scroll_position"
    - from: "apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex"
      to: "stream_insert with batched logs"
      via: "handle_info :flush_pending_logs"
      pattern: ":flush_pending_logs.*stream_insert"
---

<objective>
Close 3 verification gaps from human testing: GAP-03 (critical PubSub clogging), GAP-01 (scroll position not reflected in checkbox), and GAP-02 (toggle unresponsive during streaming).

Purpose: Human testing revealed the UI becomes unresponsive during rapid log emission. The experiment finished in 4 seconds but the UI continued updating for minutes. Additionally, scrolling away from bottom does not uncheck the auto-scroll toggle, and the toggle itself is unresponsive during high-volume streaming.

Output: Consumer-side batching in LiveView that coalesces log messages into periodic flushes, plus JS hook enhancement that pushes scroll position changes to the server.
</objective>

<execution_context>
@/Users/binarymuse/.claude/get-shit-done/workflows/execute-plan.md
@/Users/binarymuse/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-run-page-log-display/02-01-SUMMARY.md
@.planning/research/PITFALLS.md (Pitfall 2: Per-Log PubSub Message Flooding)
@apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex
@apps/athanor_web/assets/js/app.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement consumer-side log batching with send_after coalescing</name>
  <files>
    apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex
  </files>
  <action>
Modify RunLive.Show to batch incoming log messages on the consumer side instead of inserting each log individually. This addresses GAP-03 (PubSub clogging) and GAP-02 (toggle unresponsive).

**Add module attribute for batch interval:**
```elixir
@log_batch_interval_ms 100
```

**Add assign for pending logs in mount/3:**
After existing assigns, add:
```elixir
|> assign(:pending_logs, [])
```

**Replace handle_info({:log_added, log}, socket) with batching:**

Instead of immediately calling `stream_insert`, accumulate logs and schedule a flush:

```elixir
@impl true
def handle_info({:log_added, log}, socket) do
  pending = [log | socket.assigns.pending_logs]

  # Schedule flush if this is the first pending log
  socket =
    if socket.assigns.pending_logs == [] do
      Process.send_after(self(), :flush_pending_logs, @log_batch_interval_ms)
      socket
    else
      socket
    end

  {:noreply, assign(socket, :pending_logs, pending)}
end
```

**Add new handle_info for flushing:**

```elixir
@impl true
def handle_info(:flush_pending_logs, socket) do
  pending = socket.assigns.pending_logs

  if pending == [] do
    {:noreply, socket}
  else
    # Reverse to maintain chronological order (oldest first)
    logs_to_insert = Enum.reverse(pending)
    count = length(logs_to_insert)

    socket =
      socket
      |> update(:log_count, &(&1 + count))
      |> assign(:pending_logs, [])

    # Insert all pending logs with stream_insert (maintains limit)
    socket = Enum.reduce(logs_to_insert, socket, fn log, acc ->
      stream_insert(acc, :logs, log, limit: -@log_stream_limit)
    end)

    {:noreply, socket}
  end
end
```

**Keep existing handle_info({:logs_added, _count}, socket) unchanged** — it already handles batch resets correctly via database query. However, ensure it also clears pending_logs:

```elixir
# In handle_info({:logs_added, _count}, socket), add after existing assigns:
|> assign(:pending_logs, [])
```

**Result:** Log messages accumulate in `pending_logs` for up to 100ms, then flush as a batch. This reduces LiveView update cycles from hundreds per second to ~10 per second during high-volume streaming.
  </action>
  <verify>
1. `mix compile` passes with no errors
2. Start an experiment that produces rapid logs (100+ per second)
3. Verify UI remains responsive during execution
4. Verify log count updates smoothly rather than in individual increments
5. Check that auto-scroll toggle can be clicked during active logging
  </verify>
  <done>
`handle_info({:log_added, log})` accumulates to pending_logs assign. `handle_info(:flush_pending_logs)` flushes batch every 100ms. UI remains responsive during high-volume log emission.
  </done>
</task>

<task type="auto">
  <name>Task 2: Push scroll position from JS hook to disable auto-scroll on scroll-away</name>
  <files>
    apps/athanor_web/assets/js/app.js
    apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex
  </files>
  <action>
Modify the AutoScroll hook to detect when user scrolls away from bottom and push an event to the server to uncheck the auto-scroll toggle. This addresses GAP-01 (checkbox doesn't reflect scroll position).

**Update AutoScroll hook in app.js:**

Add a scroll event listener that detects when user scrolls away from bottom and pushes an event to disable auto-scroll:

```javascript
AutoScroll: {
  mounted() {
    this.scrollToBottom()

    // Track if we've pushed a scroll-away event to avoid spamming
    this.scrolledAway = false

    // Listen for user scroll to detect scroll-away intent
    this.el.addEventListener("scroll", () => {
      const nearBottom = this.isNearBottom()

      // If user scrolled away from bottom and auto-scroll is still enabled, notify server
      if (!nearBottom && this.el.dataset.autoScroll === "true" && !this.scrolledAway) {
        this.scrolledAway = true
        this.pushEvent("scroll_position", { near_bottom: false })
      }

      // Reset scrolledAway flag when user returns to bottom
      if (nearBottom) {
        this.scrolledAway = false
      }
    })

    this.observer = new MutationObserver(() => {
      if (this.el.dataset.autoScroll === "true" && this.isNearBottom()) {
        this.scrollToBottom()
      }
    })
    this.observer.observe(this.el, { childList: true, subtree: true })
  },
  updated() {
    // Called when data-auto-scroll attribute changes via server push.
    // If user just enabled auto-scroll, jump to bottom immediately and reset flag.
    if (this.el.dataset.autoScroll === "true") {
      this.scrollToBottom()
      this.scrolledAway = false
    }
  },
  destroyed() {
    if (this.observer) {
      this.observer.disconnect()
    }
  },
  isNearBottom() {
    const threshold = 100 // pixels from bottom
    return this.el.scrollHeight - this.el.scrollTop - this.el.clientHeight <= threshold
  },
  scrollToBottom() {
    this.el.scrollTop = this.el.scrollHeight
  }
}
```

**Add handle_event for scroll_position in show.ex:**

```elixir
@impl true
def handle_event("scroll_position", %{"near_bottom" => false}, socket) do
  # User scrolled away from bottom — disable auto-scroll to respect their intent
  {:noreply, assign(socket, :auto_scroll, false)}
end

def handle_event("scroll_position", %{"near_bottom" => true}, socket) do
  # User scrolled back to bottom — could re-enable auto-scroll, but let them toggle manually
  {:noreply, socket}
end
```

**Result:** When user scrolls up in the log panel, the auto-scroll checkbox automatically unchecks, reflecting user intent. The `scrolledAway` flag prevents spamming the server with events on every scroll tick.
  </action>
  <verify>
1. `mix compile` passes with no errors
2. Open a run page with active logging
3. With auto-scroll enabled (checkbox checked), scroll up in the log panel
4. Verify the auto-scroll checkbox unchecks automatically when you scroll away from bottom
5. Verify scrolling back to bottom does NOT auto-re-enable (user must toggle manually)
6. Verify toggling auto-scroll ON jumps to bottom and stays there for new logs
  </verify>
  <done>
AutoScroll hook pushes `scroll_position` event when user scrolls away from bottom. LiveView handler disables auto-scroll in response. Checkbox reflects user scroll intent.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Compile check:** `mix compile` passes with no warnings related to these changes
2. **Batching verification:** Search for `flush_pending_logs` in show.ex — should appear in both `send_after` and `handle_info`
3. **Scroll event verification:** Search for `scroll_position` in both app.js and show.ex — confirms JS-to-server connection
4. **Manual stress test:** Run an experiment that produces 1000+ logs rapidly:
   - UI should remain responsive throughout
   - Auto-scroll toggle should respond immediately to clicks
   - Scrolling up should uncheck the auto-scroll checkbox
   - Log count should update smoothly (not one-by-one)
5. **Gap closure verification:**
   - GAP-01: Scroll up in log panel → checkbox unchecks
   - GAP-02: Click toggle during rapid logging → responds immediately
   - GAP-03: Experiment finishes → UI catches up within 1-2 seconds, not minutes
</verification>

<success_criteria>
- [ ] Consumer-side batching accumulates logs and flushes every 100ms
- [ ] `handle_info(:flush_pending_logs)` batch-inserts accumulated logs
- [ ] AutoScroll hook pushes `scroll_position` event on scroll-away
- [ ] LiveView handles `scroll_position` event to disable auto-scroll
- [ ] UI remains responsive during 100+ logs/second streaming
- [ ] Auto-scroll checkbox reflects user scroll intent (unchecks on scroll-away)
- [ ] Toggle responds immediately even during high-volume streaming
- [ ] No compile warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-run-page-log-display/02-02-SUMMARY.md`
</output>
