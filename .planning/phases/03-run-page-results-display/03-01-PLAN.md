---
phase: 03-run-page-results-display
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/athanor_web/lib/athanor_web/live/experiments/components/results_panel.ex
  - apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex
autonomous: true

must_haves:
  truths:
    - "Results display as collapsible tree with expandable nodes"
    - "User can toggle between tree view and raw JSON view"
    - "New results appear in real-time as experiment produces them"
    - "Nested data structures are navigable without horizontal scrolling"
  artifacts:
    - path: "apps/athanor_web/lib/athanor_web/live/experiments/components/results_panel.ex"
      provides: "ResultsPanel Phoenix.Component with tree view and JSON toggle"
      exports: ["results_panel/1"]
    - path: "apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex"
      provides: "Wiring to ResultsPanel component"
      contains: "ResultsPanel.results_panel"
  key_links:
    - from: "results_panel.ex"
      to: "@streams.results"
      via: "streams attr passed from show.ex"
      pattern: "streams\\.results"
    - from: "results_panel.ex"
      to: "JS.toggle_class"
      via: "client-side tree expand/collapse and view toggle"
      pattern: "JS\\.toggle_class"
---

<objective>
Extract results display from RunLive.Show into a dedicated ResultsPanel component with collapsible tree view and raw JSON toggle.

Purpose: Structured experiment results need both exploration (tree navigation) and raw inspection (JSON) modes. The current inline implementation just dumps pretty-printed JSON, making nested data hard to navigate.

Output:
- `results_panel.ex` Phoenix.Component with recursive tree rendering
- Updated `show.ex` wiring to use the new component
</objective>

<execution_context>
@/Users/binarymuse/.claude/get-shit-done/workflows/execute-plan.md
@/Users/binarymuse/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-run-page-results-display/03-RESEARCH.md
@apps/athanor_web/lib/athanor_web/live/experiments/components/log_panel.ex
@apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex
@apps/athanor/lib/athanor/experiments/result.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ResultsPanel component with recursive tree view</name>
  <files>apps/athanor_web/lib/athanor_web/live/experiments/components/results_panel.ex</files>
  <action>
Create `AthanorWeb.Experiments.Components.ResultsPanel` module following LogPanel extraction pattern.

**Module structure:**

```elixir
defmodule AthanorWeb.Experiments.Components.ResultsPanel do
  use Phoenix.Component
  alias Phoenix.LiveView.JS

  attr :streams, :map, required: true
  attr :result_count, :integer, required: true

  def results_panel(assigns)
  # ... private components below
end
```

**results_panel/1 component:**
- Outer card with `bg-base-200`, card-body
- Header row: "Results" title (card-title text-lg) + result count badge (text-sm text-base-content/60)
- Empty state when `@result_count == 0`: "No results yet" centered, text-base-content/40, py-8
- Stream container: `id="results" phx-update="stream" class="space-y-3"`
- Each stream item: `bg-base-300 rounded-box p-3`, render `result_card` component

**result_card/1 component (private):**
- Header row: result.key (font-medium text-sm font-mono) + toggle button (btn btn-ghost btn-xs)
- Toggle button text: "Toggle JSON"
- Toggle button phx-click: chain `JS.toggle_class("hidden", to: "#result-tree-#{@result.id}")` with `JS.toggle_class("hidden", to: "#result-json-#{@result.id}")`
- Tree view div: `id={"result-tree-#{@result.id}"}` (shown by default), render `json_tree` with `value={@result.value}` and `node_id={@result.id}`
- JSON view div: `id={"result-json-#{@result.id}"}` with `class="hidden"` (hidden by default)
- JSON view content: `<pre class="font-mono text-xs text-base-content/80 whitespace-pre-wrap break-words">` with defensive `Jason.encode/2` (not bang version) - show "[encoding error]" on failure

**json_tree/1 recursive component (private):**

Three clauses using pattern matching and guards:

1. **Map clause** (`when is_map(value) and map_size(value) > 0`):
   - Reassign entries: `assigns = assign(assigns, :entries, Map.to_list(value))`
   - Render `<ul class="space-y-0.5">` with `<li :for={{key, val} <- @entries}>`
   - Each entry: clickable header div + children container
   - Header: `phx-click={JS.toggle_class("hidden", to: "##{@node_id}-#{key}-children") |> JS.toggle_class("rotate-90", to: "##{@node_id}-#{key}-chevron")}`
   - Header content: chevron span (id for rotation), key name, inline scalar value if leaf
   - Children container: `id={"#{@node_id}-#{key}-children"}` with `class="ml-4 border-l border-neutral pl-2"` - render recursive `json_tree` for non-scalar values
   - First-level keys (depth=0): start expanded (no "hidden" class on children)
   - Deeper levels (depth > 0): start collapsed (`class="hidden ml-4 border-l border-neutral pl-2"`)

2. **List clause** (`when is_list(value)`):
   - Reassign: `assigns = assign(assigns, :indexed, Enum.with_index(value))`
   - Render indexed items `[0]`, `[1]`, etc.
   - Non-scalar items: clickable with expand/collapse same as map
   - Scalar items: render inline value

3. **Scalar fallback clause**:
   - Render `format_scalar/1` result in `<span class="font-mono text-xs text-base-content/60">`

**Helper functions:**
- `is_scalar/1`: returns true for anything that is not a map or list
- `format_scalar/1`: nil -> "null", boolean -> "true"/"false", number -> to_string, string -> quoted

**Styling rules (from DESIGN-TOKENS.md and research):**
- Use `text-base-content` for keys
- Use `text-base-content/60` for scalar values
- Use `text-base-content/40` for chevron and decorative elements
- Use `hover:text-primary` on clickable elements
- Use `cursor-pointer` on expandable nodes
- Use `select-none` on chevron to prevent text selection
- Use `transition-transform` on chevron for smooth rotation
- Chevron character: `>` with `rotate-90` when expanded (pointing down)
- Tree container: `overflow-hidden` to prevent horizontal overflow
  </action>
  <verify>
Run `mix compile` - no warnings in results_panel.ex
Run `grep -l "results_panel" apps/athanor_web/lib/athanor_web/live/experiments/components/results_panel.ex` - file exists
  </verify>
  <done>
ResultsPanel module compiles without warnings. Contains results_panel/1, result_card/1, json_tree/1 with three clauses, is_scalar/1, and format_scalar/1.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ResultsPanel component in RunLive.Show</name>
  <files>apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex</files>
  <action>
Update `RunLive.Show` to use the extracted ResultsPanel component.

**Changes to make:**

1. Add alias at top (extend existing alias line):
   ```elixir
   alias AthanorWeb.Experiments.Components.{StatusBadge, ProgressBar, LogPanel, ResultsPanel}
   ```

2. In render/1, replace the inline results card (lines 86-107 approximately - the second div in the grid with "Results" heading) with:
   ```heex
   <ResultsPanel.results_panel streams={@streams} result_count={@result_count} />
   ```

3. Remove the entire inline results div:
   - The card with "Results" heading
   - The empty state div
   - The stream container with result rendering
   - The pre block with Jason.encode!

The mount/1, handle_info callbacks for :result_added/:results_added remain unchanged - they already do stream_insert correctly.
  </action>
  <verify>
Run `mix compile` - no warnings in show.ex
Run `grep "ResultsPanel.results_panel" apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex` - component is wired
Run `grep -c "Jason.encode!" apps/athanor_web/lib/athanor_web/live/experiments/run_live/show.ex` - should return 0 (no more inline JSON encoding in show.ex)
  </verify>
  <done>
show.ex uses ResultsPanel.results_panel component. No inline results rendering remains. Compiles without warnings.
  </done>
</task>

<task type="auto">
  <name>Task 3: Visual and functional verification</name>
  <files></files>
  <action>
Verify the ResultsPanel component works correctly by testing with the existing application.

**Steps:**

1. Start the dev server: `cd /Users/binarymuse/src/ai-reseaerch/athanor_umbrella && mix phx.server`

2. Navigate to an existing run page that has results, OR create a test by:
   - Going to experiment index
   - Creating/running an experiment that produces results
   - Observing the results panel

3. Verify success criteria:
   - Tree view renders by default with expandable nodes
   - Clicking "Toggle JSON" switches to raw JSON view and back
   - Clicking chevron/key expands/collapses nested nodes
   - No horizontal scrollbar appears on nested data
   - First-level keys are expanded by default
   - Nested levels start collapsed

If no existing run has results, create a minimal test by running an experiment (the SubstrateShift example experiment produces results).

Note: This task is verification only - if issues are found, fix them in previous task files before completing.
  </action>
  <verify>
Manually confirm in browser:
- Results panel renders with tree view
- Toggle JSON button switches views
- Tree nodes expand/collapse
- No horizontal scroll on deep nesting
  </verify>
  <done>
ResultsPanel displays correctly in browser with working tree view, JSON toggle, and expand/collapse. No horizontal scrolling issues.
  </done>
</task>

</tasks>

<verification>
1. `mix compile` passes with no warnings
2. ResultsPanel component exists at expected path
3. show.ex imports and uses ResultsPanel.results_panel
4. No inline results rendering remains in show.ex
5. Browser verification: tree view renders, toggle works, expand/collapse works, no horizontal scroll
</verification>

<success_criteria>
1. Results display as collapsible tree with expandable nodes - first level expanded, deeper levels collapsed
2. User can toggle between tree view and raw JSON view via button click
3. New results appear in real-time (existing stream infrastructure handles this)
4. Nested data structures are navigable without horizontal scrolling (overflow-hidden + break-words)
</success_criteria>

<output>
After completion, create `.planning/phases/03-run-page-results-display/03-01-SUMMARY.md`
</output>
