---
phase: 05-configuration-forms-polish
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex
  - apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex
autonomous: true

must_haves:
  truths:
    - "Configuration fields render with card-based group layout"
    - "Labels appear on their own line above full-width inputs"
    - "Required fields show red asterisk on label"
    - "Help text appears below label, above input"
    - "String fields render as text input or textarea based on format"
    - "Integer fields render with min/max/step constraints"
    - "Boolean fields render as checkboxes"
    - "Enum fields render as select dropdowns"
    - "Groups render in their own cards with headers"
    - "Ungrouped fields render in a default card"
  artifacts:
    - path: "apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex"
      provides: "ConfigFormComponent with config_form/1, config_group/1, config_field/1, config_list_field/1 stub"
      exports: ["config_form"]
    - path: "apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex"
      provides: "Slimmed down LiveView using ConfigFormComponent"
      contains: "ConfigFormComponent.config_form"
  key_links:
    - from: "apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex"
      to: "apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex"
      via: "import or alias"
      pattern: "config_form.*schema"
    - from: "apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex"
      to: "apps/athanor/lib/experiment/config_schema.ex"
      via: "schema.properties iteration"
      pattern: "for.*<-.*properties"
---

<objective>
Extract configuration form rendering into ConfigFormComponent with card-based group layout and all scalar field types.

Purpose: Clean separation of concerns - form rendering logic moves to a dedicated component module, enabling proper field styling per user decisions (stacked labels, help text, required asterisks, format-aware inputs).

Output: Working ConfigFormComponent rendering grouped scalar fields, integrated into InstanceLive.New.
</objective>

<execution_context>
@/Users/binarymuse/.claude/get-shit-done/workflows/execute-plan.md
@/Users/binarymuse/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-configuration-forms-polish/05-CONTEXT.md
@.planning/phases/05-configuration-forms-polish/05-RESEARCH.md
@.planning/phases/05-configuration-forms-polish/05-01-SUMMARY.md

@apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex
@apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex
@apps/athanor_web/lib/athanor_web/components/core_components.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConfigFormComponent with scalar field rendering and default card for ungrouped fields</name>
  <files>apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex</files>
  <action>
Create a new Phoenix.Component module for configuration form rendering. Follow the pattern from existing components (log_panel.ex, results_panel.ex).

1. Module setup:
   ```elixir
   defmodule AthanorWeb.Experiments.Components.ConfigFormComponent do
     use Phoenix.Component
     import AthanorWeb.CoreComponents, only: [icon: 1]

     # Main entry point
     attr :schema, :map, required: true
     attr :path, :list, default: []
     attr :values, :map, default: %{}
     attr :errors, :map, default: %{}
     attr :touched, :any, default: nil  # MapSet

     def config_form(assigns)
   ```

2. Implement `config_form/1` with ungrouped fields wrapped in a default card (per user decision):
   - Iterate over `schema.properties` (now a list of {name, field_def} tuples)
   - **CRITICAL: Group consecutive ungrouped fields (scalars and lists) into a default card**
   - Dispatch to `config_group/1` for type: :group (renders its own card)
   - Collect consecutive non-group fields and wrap them in `default_card/1`

   Implementation pattern:
   ```elixir
   def config_form(assigns) do
     # Partition properties into runs of groups vs ungrouped
     grouped_runs = group_into_runs(assigns.schema.properties)
     assigns = assign(assigns, :grouped_runs, grouped_runs)

     ~H"""
     <%= for run <- @grouped_runs do %>
       <%= case run do %>
         <% {:group, name, field_def} -> %>
           <.config_group name={name} field_def={field_def} ... />
         <% {:ungrouped, fields} -> %>
           <.default_card fields={fields} ... />
       <% end %>
     <% end %>
     """
   end

   defp group_into_runs(properties) do
     # Returns list of {:group, name, def} or {:ungrouped, [{name, def}, ...]}
     # Consecutive non-group fields are collected together
   end
   ```

3. Implement `default_card/1` for ungrouped fields (per user decision: "ungrouped fields in a default card"):
   ```heex
   defp default_card(assigns) do
     ~H"""
     <div class="card bg-base-200 mb-4">
       <div class="card-body p-4">
         <%= for {name, field_def} <- @fields do %>
           <%= case field_def.type do %>
             <% :list -> %>
               <.config_list_field name={name} field_def={field_def} ... />
             <% _ -> %>
               <.config_scalar_field name={name} field_def={field_def} ... />
           <% end %>
         <% end %>
       </div>
     </div>
     """
   end
   ```

4. **CRITICAL: Add a stub for `config_list_field/1` to allow compilation:**
   ```elixir
   # Stub for list fields - will be fully implemented in Plan 03
   # This placeholder renders a card with "Add" button and placeholder text.
   # Plan 03 Task 2 will replace this with full collapsible item implementation.
   defp config_list_field(assigns) do
     ~H"""
     <div class="card bg-base-300 mb-4">
       <div class="card-body p-3">
         <div class="flex items-center justify-between">
           <div>
             <h4 class="text-sm font-medium">{@field_def[:label] || humanize(@name)}</h4>
             <p :if={@field_def[:description]} class="text-xs text-base-content/60">
               {@field_def.description}
             </p>
           </div>
           <button
             type="button"
             phx-click="add_list_item"
             phx-value-path={path_to_key(@path ++ [@name])}
             class="btn btn-sm btn-outline"
           >
             <.icon name="hero-plus" class="size-4" /> Add
           </button>
         </div>
         <p class="text-xs text-base-content/50 italic mt-2">
           List items will render here (Plan 03)
         </p>
       </div>
     </div>
     """
   end
   ```

5. Implement `config_group/1`:
   - Render card bg-base-200 with card-body
   - Card title from field_def.label or humanize(name)
   - Optional description paragraph below title
   - Recursively call config_form/1 for sub_schema

6. Implement `config_scalar_field/1` with pattern matching on field_def.type:
   - `:string` - check field_def.format:
     - :textarea -> textarea element
     - default -> text input
   - `:integer` -> number input with min/max/step attributes
   - `:boolean` -> checkbox (per user decision, not toggle switch)
   - `:enum` -> select with options from field_def.options

7. Field layout pattern (stacked labels per user decision):
   ```heex
   <div class="fieldset mb-4">
     <label class="block">
       <span class="label mb-1">
         {field_def.label || humanize(name)}
         <span :if={field_def[:required]} class="text-error ml-1">*</span>
       </span>
       <p :if={field_def[:description]} class="text-xs text-base-content/60 mb-2">
         {field_def.description}
       </p>
       <input ... />
     </label>
     <.field_error :if={has_error?(errors, path)} message={get_error(errors, path)} />
   </div>
   ```

8. Helper functions:
   - `field_name/1` - builds "instance[configuration][path][parts]" name
   - `get_value/2` - gets value from values map by path
   - `humanize/1` - converts atom/string to title case
   - `has_error?/2`, `get_error/2` - error lookup helpers
   - `field_error/1` - renders error message with icon (match core_components pattern)
   - `path_to_key/1` - converts path list to dot-separated string key

9. Replace `form-control` class with `fieldset mb-4` (per research - form-control deleted in daisyUI 5)

10. Use `input w-full`, `textarea w-full`, `select w-full`, `checkbox` classes
   - Add `input-error`, `textarea-error`, `select-error` when errors present
  </action>
  <verify>
Run `mix compile` in athanor_web - no warnings.
Module exports config_form/1 function.
`config_list_field/1` stub exists and compiles (renders placeholder).
  </verify>
  <done>
ConfigFormComponent renders all scalar field types (string, integer, boolean, enum) with proper styling: stacked labels, required asterisks, help text, format-aware inputs, error state classes. Ungrouped fields are wrapped in a default bg-base-200 card per user decision. List fields have a stub that compiles and renders a placeholder with "Add" button.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate ConfigFormComponent into InstanceLive.New and update property access for list structure</name>
  <files>apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex</files>
  <action>
Refactor InstanceLive.New to use the new ConfigFormComponent, removing duplicate rendering logic. CRITICAL: Update all functions that access schema.properties to work with the new list-of-tuples structure.

1. Add import at top of module:
   ```elixir
   import AthanorWeb.Experiments.Components.ConfigFormComponent, only: [config_form: 1]
   ```

2. Update socket assigns in mount to include validation state:
   ```elixir
   |> assign(:config_errors, %{})
   |> assign(:config_touched, MapSet.new())
   |> assign(:config_values, %{})
   ```

3. Replace the config fields rendering in render/1:
   ```heex
   <div :if={@config_schema} class="space-y-4">
     <div class="divider">Configuration</div>
     <.config_form
       schema={@config_schema}
       path={[]}
       values={@config_values}
       errors={@config_errors}
       touched={@config_touched}
     />
   </div>
   ```

4. Remove all `defp render_config_field` clauses (except the list one - keep for now, will be replaced in Plan 03)

5. Remove `defp render_list_item_field` clauses (will be replaced in Plan 03)

6. Update handle_event("validate", ...) to track config values:
   - Extract config values from params["configuration"]
   - Store in :config_values assign
   - For now, skip validation logic (Plan 03 adds full validation)

7. Replace remaining `form-control` classes with `fieldset mb-2` in the experiment selector and instance details sections

8. **CRITICAL: Update `get_item_schema_for_path/2` to work with list-based properties:**
   ```elixir
   defp get_item_schema_for_path(schema, [name]) do
     name_atom = String.to_existing_atom(name)
     # Properties is now a list of {name, field_def} tuples, not a map
     case Enum.find_value(schema.properties, fn {n, def} -> if n == name_atom, do: def end) do
       %{item_schema: item_schema} -> item_schema
       _ -> nil
     end
   rescue
     _ -> nil
   end
   ```

9. **CRITICAL: Update `initialize_list_items/2` to work with list-based properties:**
   ```elixir
   defp initialize_list_items(schema, path) do
     # schema.properties is now a list of {name, field_def} tuples
     Enum.reduce(schema.properties, %{}, fn {name, field_def}, acc ->
       current_path = path ++ [name]

       case field_def do
         %{type: :list, item_schema: item_schema} ->
           path_key = Enum.map_join(current_path, ".", &to_string/1)
           defaults = build_list_defaults(field_def, item_schema)
           Map.put(acc, path_key, defaults)

         _ ->
           acc
       end
     end)
   end
   ```

10. **CRITICAL: Update `add_list_item` event handler to use list-based lookup:**
    - The `add_list_item` handler calls `get_item_schema_for_path/2` which is now updated
    - Also update the item creation to iterate `item_schema.properties` as a list:
    ```elixir
    def handle_event("add_list_item", %{"path" => path_key}, socket) do
      schema = socket.assigns.config_schema
      item_schema = get_item_schema_for_path(schema, String.split(path_key, "."))

      # item_schema.properties is a list of {name, field_def} tuples
      new_item =
        Enum.reduce(item_schema.properties, %{}, fn {name, field_def}, acc ->
          Map.put(acc, to_string(name), field_def[:default])
        end)

      list_items =
        Map.update(socket.assigns.list_items, path_key, [new_item], &(&1 ++ [new_item]))

      {:noreply, assign(socket, :list_items, list_items)}
    end
    ```

11. Keep existing remove_list_item event handler - will be refactored in Plan 03
  </action>
  <verify>
Run `mix phx.server` and navigate to /experiments/new.
Select an experiment - configuration form renders with new component.
Scalar fields show labels, help text, required asterisks.
Ungrouped fields appear inside a default card container.
Click "Add" on list fields - new items are created without error.
Form submits successfully (existing save logic unchanged).
  </verify>
  <done>
InstanceLive.New uses ConfigFormComponent for scalar field rendering. Old render_config_field logic removed. Form-control classes replaced with fieldset. Validation state assigns in place for Plan 03. All property access functions (get_item_schema_for_path, initialize_list_items, add_list_item) updated to work with list-of-tuples properties structure.
  </done>
</task>

</tasks>

<verification>
1. `mix compile` succeeds with no warnings
2. Navigate to /experiments/new, select SubstrateShift experiment
3. "Runs Per Pair" field shows:
   - Label with red asterisk (required)
   - Help text below label
   - Number input with min/max/step attributes
4. Ungrouped fields (like runs_per_pair) appear inside a default bg-base-200 card
5. Model pairs list field shows stub card with "Add" button and placeholder text
6. Click "Add" on list field - creates new item without crashing
7. Form submission still works
</verification>

<success_criteria>
- ConfigFormComponent module exists with config_form/1 public function
- config_list_field/1 stub exists and compiles (placeholder for Plan 03)
- Scalar fields render with stacked label layout
- Required fields show red asterisk
- Description/help text appears when defined in schema
- String fields respect format option (textarea vs text input)
- Integer fields have min/max/step HTML attributes
- Boolean fields render as checkboxes
- Enum fields render as selects with options
- Groups render in separate cards with headers
- Ungrouped fields render in a default card (per user decision)
- InstanceLive.New delegates to ConfigFormComponent
- form-control classes eliminated (daisyUI 5 compatibility)
- Property access functions work with list-of-tuples structure
- add_list_item creates new items correctly with list-based schema
</success_criteria>

<output>
After completion, create `.planning/phases/05-configuration-forms-polish/05-02-SUMMARY.md`
</output>
