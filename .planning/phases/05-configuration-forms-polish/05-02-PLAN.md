---
phase: 05-configuration-forms-polish
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex
  - apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex
autonomous: true

must_haves:
  truths:
    - "Configuration fields render with card-based group layout"
    - "Labels appear on their own line above full-width inputs"
    - "Required fields show red asterisk on label"
    - "Help text appears below label, above input"
    - "String fields render as text input or textarea based on format"
    - "Integer fields render with min/max/step constraints"
    - "Boolean fields render as checkboxes"
    - "Enum fields render as select dropdowns"
    - "Groups render in their own cards with headers"
    - "Ungrouped fields render in a default card"
  artifacts:
    - path: "apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex"
      provides: "ConfigFormComponent with config_form/1, config_group/1, config_field/1"
      exports: ["config_form"]
    - path: "apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex"
      provides: "Slimmed down LiveView using ConfigFormComponent"
      contains: "ConfigFormComponent.config_form"
  key_links:
    - from: "apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex"
      to: "apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex"
      via: "import or alias"
      pattern: "config_form.*schema"
    - from: "apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex"
      to: "apps/athanor/lib/experiment/config_schema.ex"
      via: "schema.properties iteration"
      pattern: "for.*<-.*properties"
---

<objective>
Extract configuration form rendering into ConfigFormComponent with card-based group layout and all scalar field types.

Purpose: Clean separation of concerns - form rendering logic moves to a dedicated component module, enabling proper field styling per user decisions (stacked labels, help text, required asterisks, format-aware inputs).

Output: Working ConfigFormComponent rendering grouped scalar fields, integrated into InstanceLive.New.
</objective>

<execution_context>
@/Users/binarymuse/.claude/get-shit-done/workflows/execute-plan.md
@/Users/binarymuse/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-configuration-forms-polish/05-CONTEXT.md
@.planning/phases/05-configuration-forms-polish/05-RESEARCH.md
@.planning/phases/05-configuration-forms-polish/05-01-SUMMARY.md

@apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex
@apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex
@apps/athanor_web/lib/athanor_web/components/core_components.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConfigFormComponent with scalar field rendering</name>
  <files>apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex</files>
  <action>
Create a new Phoenix.Component module for configuration form rendering. Follow the pattern from existing components (log_panel.ex, results_panel.ex).

1. Module setup:
   ```elixir
   defmodule AthanorWeb.Experiments.Components.ConfigFormComponent do
     use Phoenix.Component
     import AthanorWeb.CoreComponents, only: [icon: 1]

     # Main entry point
     attr :schema, :map, required: true
     attr :path, :list, default: []
     attr :values, :map, default: %{}
     attr :errors, :map, default: %{}
     attr :touched, :any, default: nil  # MapSet

     def config_form(assigns)
   ```

2. Implement `config_form/1`:
   - Iterate over `schema.properties` (now a list of {name, field_def} tuples)
   - Dispatch to `config_group/1` for type: :group
   - Dispatch to `config_list_field/1` for type: :list (stub for now - "List fields coming soon")
   - Dispatch to `config_scalar_field/1` for all other types

3. Implement `config_group/1`:
   - Render card bg-base-200 with card-body
   - Card title from field_def.label or humanize(name)
   - Optional description paragraph below title
   - Recursively call config_form/1 for sub_schema

4. Implement `config_scalar_field/1` with pattern matching on field_def.type:
   - `:string` - check field_def.format:
     - :textarea -> textarea element
     - default -> text input
   - `:integer` -> number input with min/max/step attributes
   - `:boolean` -> checkbox (per user decision, not toggle switch)
   - `:enum` -> select with options from field_def.options

5. Field layout pattern (stacked labels per user decision):
   ```heex
   <div class="fieldset mb-4">
     <label class="block">
       <span class="label mb-1">
         {field_def.label || humanize(name)}
         <span :if={field_def[:required]} class="text-error ml-1">*</span>
       </span>
       <p :if={field_def[:description]} class="text-xs text-base-content/60 mb-2">
         {field_def.description}
       </p>
       <input ... />
     </label>
     <.field_error :if={has_error?(errors, path)} message={get_error(errors, path)} />
   </div>
   ```

6. Helper functions:
   - `field_name/1` - builds "instance[configuration][path][parts]" name
   - `get_value/2` - gets value from values map by path
   - `humanize/1` - converts atom/string to title case
   - `has_error?/2`, `get_error/2` - error lookup helpers
   - `field_error/1` - renders error message with icon (match core_components pattern)

7. Replace `form-control` class with `fieldset mb-4` (per research - form-control deleted in daisyUI 5)

8. Use `input w-full`, `textarea w-full`, `select w-full`, `checkbox` classes
   - Add `input-error`, `textarea-error`, `select-error` when errors present
  </action>
  <verify>
Run `mix compile` in athanor_web - no warnings.
Module exports config_form/1 function.
  </verify>
  <done>
ConfigFormComponent renders all scalar field types (string, integer, boolean, enum) with proper styling: stacked labels, required asterisks, help text, format-aware inputs, error state classes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate ConfigFormComponent into InstanceLive.New</name>
  <files>apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex</files>
  <action>
Refactor InstanceLive.New to use the new ConfigFormComponent, removing duplicate rendering logic.

1. Add import at top of module:
   ```elixir
   import AthanorWeb.Experiments.Components.ConfigFormComponent, only: [config_form: 1]
   ```

2. Update socket assigns in mount to include validation state:
   ```elixir
   |> assign(:config_errors, %{})
   |> assign(:config_touched, MapSet.new())
   |> assign(:config_values, %{})
   ```

3. Replace the config fields rendering in render/1:
   ```heex
   <div :if={@config_schema} class="space-y-4">
     <div class="divider">Configuration</div>
     <.config_form
       schema={@config_schema}
       path={[]}
       values={@config_values}
       errors={@config_errors}
       touched={@config_touched}
     />
   </div>
   ```

4. Remove all `defp render_config_field` clauses (except the list one - keep for now, will be replaced in Plan 03)

5. Remove `defp render_list_item_field` clauses (will be replaced in Plan 03)

6. Update handle_event("validate", ...) to track config values:
   - Extract config values from params["configuration"]
   - Store in :config_values assign
   - For now, skip validation logic (Plan 03 adds full validation)

7. Replace remaining `form-control` classes with `fieldset mb-2` in the experiment selector and instance details sections

8. Keep existing list item handling (add_list_item, remove_list_item events) - will be refactored in Plan 03
  </action>
  <verify>
Run `mix phx.server` and navigate to /experiments/new.
Select an experiment - configuration form renders with new component.
Scalar fields show labels, help text, required asterisks.
Form submits successfully (existing save logic unchanged).
  </verify>
  <done>
InstanceLive.New uses ConfigFormComponent for scalar field rendering. Old render_config_field logic removed. Form-control classes replaced with fieldset. Validation state assigns in place for Plan 03.
  </done>
</task>

</tasks>

<verification>
1. `mix compile` succeeds with no warnings
2. Navigate to /experiments/new, select SubstrateShift experiment
3. "Runs Per Pair" field shows:
   - Label with red asterisk (required)
   - Help text below label
   - Number input with min/max/step attributes
4. Model pairs list field shows placeholder (list handling comes in Plan 03)
5. Form submission still works
</verification>

<success_criteria>
- ConfigFormComponent module exists with config_form/1 public function
- Scalar fields render with stacked label layout
- Required fields show red asterisk
- Description/help text appears when defined in schema
- String fields respect format option (textarea vs text input)
- Integer fields have min/max/step HTML attributes
- Boolean fields render as checkboxes
- Enum fields render as selects with options
- Groups render in separate cards with headers
- InstanceLive.New delegates to ConfigFormComponent
- form-control classes eliminated (daisyUI 5 compatibility)
</success_criteria>

<output>
After completion, create `.planning/phases/05-configuration-forms-polish/05-02-SUMMARY.md`
</output>
