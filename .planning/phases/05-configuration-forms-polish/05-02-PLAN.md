---
phase: 05-configuration-forms-polish
plan: 02
type: execute
wave: 1
depends_on:
  - "05-01"
files_modified:
  - apps/athanor/lib/experiment/config_schema.ex
  - apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex
  - apps/athanor_web/assets/js/app.js
  - apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex
autonomous: true
requirements:
  - CFG-01

must_haves:
  truths:
    - "Schema is serialized to JSON for JavaScript consumption"
    - "Hook renders scalar fields (string, integer, boolean, enum) from schema"
    - "Form submits config as JSON via hidden input"
    - "Server decodes config JSON and saves instance"
    - "Old server-side list management code is removed"
  artifacts:
    - path: "apps/athanor/lib/experiment/config_schema.ex"
      provides: "to_serializable/1 function"
      contains: "def to_serializable"
    - path: "apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex"
      provides: "ConfigFormComponent with config_form/1"
      contains: "def config_form"
    - path: "apps/athanor_web/assets/js/app.js"
      provides: "ConfigFormHook with scalar field rendering"
      contains: "ConfigFormHook"
  key_links:
    - from: "apps/athanor/lib/experiment/config_schema.ex"
      to: "apps/athanor_web/assets/js/app.js"
      via: "JSON serialization via to_serializable/1"
      pattern: "to_serializable"
    - from: "apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex"
      to: "apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex"
      via: "ConfigFormComponent.config_form/1 call"
      pattern: "config_form"
---

<objective>
Create ConfigFormComponent and ConfigFormHook to render scalar configuration fields client-side.

Purpose: Replace server-side form state management with a JS hook that owns form state. This eliminates race conditions between typing and add/remove operations, and simplifies nested list handling (Plan 03).

Output: Working scalar field rendering (string, integer, boolean, enum) via JS hook, with form submission via hidden JSON input.
</objective>

<execution_context>
@/Users/binarymuse/.claude/get-shit-done/workflows/execute-plan.md
@/Users/binarymuse/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-configuration-forms-polish/05-CONTEXT.md
@.planning/phases/05-configuration-forms-polish/05-RESEARCH.md
@.planning/phases/05-configuration-forms-polish/05-01-SUMMARY.md

@apps/athanor/lib/experiment/config_schema.ex
@apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex
@apps/athanor_web/assets/js/app.js
@apps/athanor_web/lib/athanor_web/components/core_components.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ConfigSchema.to_serializable/1 and ConfigFormComponent</name>
  <files>apps/athanor/lib/experiment/config_schema.ex, apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex</files>
  <action>
1. Add `to_serializable/1` to ConfigSchema that converts the struct to a JSON-serializable map:
   ```elixir
   def to_serializable(%__MODULE__{} = schema) do
     %{
       "type" => to_string(schema.type),
       "properties" => Enum.map(schema.properties, fn {name, def} ->
         %{"name" => to_string(name), "definition" => serialize_field_def(def)}
       end)
     }
   end

   defp serialize_field_def(%{type: :group, sub_schema: sub} = def) do
     def
     |> Map.delete(:sub_schema)
     |> Map.put(:sub_schema, to_serializable(sub))
     |> stringify_field_def()
   end

   defp serialize_field_def(%{type: :list, item_schema: item} = def) do
     def
     |> Map.delete(:item_schema)
     |> Map.put(:item_schema, to_serializable(item))
     |> stringify_field_def()
   end

   defp serialize_field_def(def) do
     stringify_field_def(def)
   end

   defp stringify_field_def(def) do
     Map.new(def, fn {k, v} ->
       key = to_string(k)
       val = cond do
         is_atom(v) -> to_string(v)
         is_list(v) -> Enum.map(v, &to_string/1)  # for options
         true -> v
       end
       {key, val}
     end)
   end
   ```

2. Create `apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex`:
   ```elixir
   defmodule AthanorWeb.Experiments.Components.ConfigFormComponent do
     use Phoenix.Component

     attr :schema_json, :string, required: true

     def config_form(assigns) do
       ~H"""
       <div
         id="config-form-hook"
         phx-hook="ConfigFormHook"
         data-schema={@schema_json}
         phx-update="ignore"
       >
         <input type="hidden" name="instance[configuration_json]" id="config-json-input" />
         <!-- Hook renders all form fields dynamically -->
       </div>
       """
     end
   end
   ```

The component is minimal because the JS hook does all rendering. The `phx-update="ignore"` prevents LiveView from overwriting hook-managed DOM.
  </action>
  <verify>
Run `mix compile` in umbrella root - no errors or warnings.
Run iex: `SubstrateShift.config() |> Athanor.Experiment.ConfigSchema.to_serializable() |> Jason.encode!()` should produce valid JSON with string keys.
  </verify>
  <done>
ConfigSchema has to_serializable/1 that produces JSON-safe maps. ConfigFormComponent exists with config_form/1 that renders hook container.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ConfigFormHook for scalar fields and update InstanceLive.New</name>
  <files>apps/athanor_web/assets/js/app.js, apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex</files>
  <action>
1. Add ConfigFormHook to app.js Hooks object:
   ```javascript
   ConfigFormHook: {
     mounted() {
       this.schema = JSON.parse(this.el.dataset.schema)
       this.state = this.initStateFromSchema(this.schema)
       this.render()
       this.bindEvents()
     },

     handleEvent(event, payload) {
       if (event === "config_schema_changed") {
         this.schema = JSON.parse(payload.schema_json)
         this.state = this.initStateFromSchema(this.schema)
         this.render()
       }
     },

     bindEvents() {
       // Track input changes
       this.el.addEventListener("input", (e) => {
         if (e.target.dataset.fieldPath) {
           const path = JSON.parse(e.target.dataset.fieldPath)
           const type = e.target.dataset.fieldType
           this.updateState(path, this.coerceValue(e.target.value, type))
         }
       })

       // Handle checkbox changes
       this.el.addEventListener("change", (e) => {
         if (e.target.type === "checkbox" && e.target.dataset.fieldPath) {
           const path = JSON.parse(e.target.dataset.fieldPath)
           this.updateState(path, e.target.checked)
         }
       })

       // Set hidden input before form submits
       const form = this.el.closest("form")
       if (form) {
         form.addEventListener("submit", () => {
           const hiddenInput = document.getElementById("config-json-input")
           if (hiddenInput) hiddenInput.value = JSON.stringify(this.state)
         })
       }
     },

     coerceValue(rawValue, type) {
       if (type === "integer") return parseInt(rawValue, 10) || 0
       if (type === "number") return parseFloat(rawValue) || 0
       return rawValue
     },

     initStateFromSchema(schema) {
       return schema.properties.reduce((acc, {name, definition}) => {
         if (definition.type === "list") {
           acc[name] = []
         } else if (definition.type === "group") {
           acc[name] = this.initStateFromSchema(definition.sub_schema)
         } else {
           acc[name] = definition.default ?? null
         }
         return acc
       }, {})
     },

     updateState(path, value) {
       let obj = this.state
       for (let i = 0; i < path.length - 1; i++) {
         obj = obj[path[i]]
       }
       obj[path[path.length - 1]] = value
     },

     render() {
       // Keep the hidden input, render fields after it
       const hiddenInput = this.el.querySelector("#config-json-input")
       const fragment = document.createDocumentFragment()
       this.renderProperties(fragment, this.schema.properties, [])

       // Clear and re-add
       this.el.innerHTML = ""
       this.el.appendChild(hiddenInput.cloneNode())
       this.el.appendChild(fragment)
     },

     renderProperties(parent, properties, path) {
       for (const {name, definition} of properties) {
         const fieldPath = [...path, name]
         const value = this.getStateValue(fieldPath)

         if (definition.type === "list") {
           // Plan 03 will handle lists - render placeholder
           parent.appendChild(this.createListPlaceholder(name, definition, fieldPath))
         } else if (definition.type === "group") {
           parent.appendChild(this.renderGroup(name, definition, fieldPath))
         } else {
           parent.appendChild(this.renderScalarField(name, definition, fieldPath, value))
         }
       }
     },

     getStateValue(path) {
       let obj = this.state
       for (const key of path) {
         if (obj === undefined || obj === null) return undefined
         obj = obj[key]
       }
       return obj
     },

     renderGroup(name, definition, path) {
       const card = document.createElement("div")
       card.className = "card bg-base-200 mb-4"

       const body = document.createElement("div")
       body.className = "card-body gap-4"

       const title = document.createElement("h3")
       title.className = "card-title text-base"
       title.textContent = definition.label || this.humanize(name)
       body.appendChild(title)

       if (definition.description) {
         const desc = document.createElement("p")
         desc.className = "text-sm text-base-content/70"
         desc.textContent = definition.description
         body.appendChild(desc)
       }

       this.renderProperties(body, definition.sub_schema.properties, path)
       card.appendChild(body)
       return card
     },

     renderScalarField(name, definition, path, value) {
       const wrapper = document.createElement("div")
       wrapper.className = "fieldset mb-2"

       const label = document.createElement("label")
       const labelSpan = document.createElement("span")
       labelSpan.className = "label mb-1"
       labelSpan.textContent = definition.label || this.humanize(name)

       if (definition.required) {
         const asterisk = document.createElement("span")
         asterisk.className = "text-error ml-1"
         asterisk.textContent = "*"
         labelSpan.appendChild(asterisk)
       }
       label.appendChild(labelSpan)

       if (definition.description) {
         const desc = document.createElement("p")
         desc.className = "text-xs text-base-content/60 mb-1"
         desc.textContent = definition.description
         label.appendChild(desc)
       }

       const input = this.createInput(name, definition, path, value)
       label.appendChild(input)
       wrapper.appendChild(label)

       return wrapper
     },

     createInput(name, definition, path, value) {
       const pathJson = JSON.stringify(path)

       // Boolean -> checkbox
       if (definition.type === "boolean") {
         const container = document.createElement("div")
         container.className = "flex items-center gap-2"
         const checkbox = document.createElement("input")
         checkbox.type = "checkbox"
         checkbox.className = "checkbox"
         checkbox.checked = value === true
         checkbox.dataset.fieldPath = pathJson
         container.appendChild(checkbox)
         return container
       }

       // Enum -> select
       if (definition.type === "enum" && definition.options) {
         const select = document.createElement("select")
         select.className = "select w-full"
         select.dataset.fieldPath = pathJson
         select.dataset.fieldType = "string"

         for (const opt of definition.options) {
           const option = document.createElement("option")
           option.value = opt
           option.textContent = this.humanize(opt)
           if (value === opt) option.selected = true
           select.appendChild(option)
         }
         return select
       }

       // Textarea format
       if (definition.format === "textarea") {
         const textarea = document.createElement("textarea")
         textarea.className = "textarea w-full"
         textarea.value = value ?? ""
         textarea.dataset.fieldPath = pathJson
         textarea.dataset.fieldType = "string"
         return textarea
       }

       // Integer/number
       if (definition.type === "integer" || definition.type === "number") {
         const input = document.createElement("input")
         input.type = "number"
         input.className = "input w-full"
         input.value = value ?? ""
         input.dataset.fieldPath = pathJson
         input.dataset.fieldType = definition.type
         if (definition.min !== undefined) input.min = definition.min
         if (definition.max !== undefined) input.max = definition.max
         if (definition.step !== undefined) input.step = definition.step
         return input
       }

       // String with format hints
       const input = document.createElement("input")
       input.className = "input w-full"
       input.value = value ?? ""
       input.dataset.fieldPath = pathJson
       input.dataset.fieldType = "string"

       switch (definition.format) {
         case "email":
           input.type = "email"
           break
         case "url":
           input.type = "url"
           break
         default:
           input.type = "text"
       }

       return input
     },

     createListPlaceholder(name, definition, path) {
       const div = document.createElement("div")
       div.className = "border border-base-300 rounded-lg p-4 mb-4"
       div.dataset.listPath = JSON.stringify(path)

       const header = document.createElement("div")
       header.className = "flex items-center justify-between mb-2"

       const label = document.createElement("span")
       label.className = "font-semibold"
       label.textContent = definition.label || this.humanize(name)
       header.appendChild(label)

       div.appendChild(header)

       const placeholder = document.createElement("p")
       placeholder.className = "text-sm text-base-content/60"
       placeholder.textContent = "List fields will be enabled in the next update."
       div.appendChild(placeholder)

       return div
     },

     humanize(str) {
       return str
         .replace(/_/g, " ")
         .replace(/\b\w/g, c => c.toUpperCase())
     }
   }
   ```

2. Update InstanceLive.New:
   a. Add import for ConfigFormComponent at top:
      ```elixir
      alias AthanorWeb.Experiments.Components.ConfigFormComponent
      ```

   b. Add `config_schema_json` assign in mount (initial nil):
      ```elixir
      |> assign(:config_schema_json, nil)
      ```

   c. In `handle_event("select_experiment", ...)` success case, compute and assign schema_json:
      ```elixir
      schema_json = schema |> ConfigSchema.to_serializable() |> Jason.encode!()
      # ... existing assigns ...
      |> assign(:config_schema_json, schema_json)
      ```

   d. Also add `push_event` for schema changes (so hook can re-init):
      ```elixir
      |> push_event("config_schema_changed", %{schema_json: schema_json})
      ```

   e. Replace the config fields rendering in `render/1`:
      From:
      ```heex
      <div :if={@config_schema} class="space-y-4">
        <div class="divider">Configuration</div>
        <.render_config_fields ... />
      </div>
      ```
      To:
      ```heex
      <div :if={@config_schema_json} class="space-y-4">
        <div class="divider">Configuration</div>
        <ConfigFormComponent.config_form schema_json={@config_schema_json} />
      </div>
      ```

   f. Update `handle_event("save", ...)` to decode config from JSON:
      ```elixir
      def handle_event("save", %{"instance" => params}, socket) do
        config =
          case params["configuration_json"] do
            nil -> %{}
            "" -> %{}
            json ->
              case Jason.decode(json) do
                {:ok, decoded} -> decoded
                {:error, _} -> %{}
              end
          end

        params =
          params
          |> Map.put("configuration", config)
          |> Map.delete("configuration_json")

        case Experiments.create_instance(params) do
          # ... existing code unchanged ...
        end
      end
      ```

   g. Remove `phx-change="validate"` from the form tag (config inputs don't need server validation during typing).

   h. Delete the obsolete code:
      - Remove `list_items` from mount assigns
      - Remove `render_config_fields/1` and all `render_config_field/1` function clauses
      - Remove `render_list_item_field/1` function clauses
      - Remove `field_name/1`, `list_item_field_name/3`, `path_to_key/1`, `humanize/1` helpers
      - Remove `handle_event("add_list_item", ...)` handler
      - Remove `handle_event("remove_list_item", ...)` handler
      - Remove `handle_event("validate", ...)` handler
      - Remove `initialize_list_items/2`, `get_item_schema_for_path/2`, `extract_list_items/2`, `parse_configuration/2`, `has_indexed_keys?/1`, `parse_config_value/1` helpers
      - Remove `list_items` from the empty experiment select handler

   i. Replace `class="form-control"` with `class="fieldset mb-2"` in the Experiment Type select wrapper.
  </action>
  <verify>
1. Run `mix compile` - no errors or warnings
2. Start server with `mix phx.server`
3. Navigate to `/experiments/new`
4. Select an experiment - config fields should render via JS hook
5. Fill in scalar fields, submit form - instance should be created with correct configuration
  </verify>
  <done>
ConfigFormHook renders scalar fields (string, integer, boolean, enum with options, textarea format). Form submission serializes state to hidden input. Server decodes JSON and saves. All obsolete server-side list management code removed.
  </done>
</task>

</tasks>

<verification>
1. `mix compile` passes without warnings
2. ConfigSchema.to_serializable/1 produces JSON-safe map with string keys
3. Selecting an experiment renders config fields via JS hook
4. Scalar inputs (text, number, checkbox, select, textarea) work correctly
5. Form submission creates instance with correct configuration
6. No `phx-change` on config inputs - state is client-side only
7. No obsolete code remains (list_items, render_config_fields, etc.)
</verification>

<success_criteria>
- ConfigSchema.to_serializable/1 converts struct to JSON-serializable format
- ConfigFormComponent renders hook container with phx-update="ignore"
- ConfigFormHook renders scalar fields from schema JSON
- Form submission via hidden input works end-to-end
- Instance created with correct configuration values
- Old server-side form state code is deleted
</success_criteria>

<output>
After completion, create `.planning/phases/05-configuration-forms-polish/05-02-SUMMARY.md`
</output>
