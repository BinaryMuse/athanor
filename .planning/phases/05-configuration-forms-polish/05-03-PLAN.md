---
phase: 05-configuration-forms-polish
plan: 03
type: execute
wave: 3
depends_on:
  - "05-02"
files_modified:
  - apps/athanor_web/assets/js/app.js
autonomous: true
requirements:
  - CFG-01

must_haves:
  truths:
    - "List fields render with add/remove functionality"
    - "List items are collapsible to a summary line"
    - "List items can be reordered with up/down buttons"
    - "Required field validation shows inline errors on blur and submit"
    - "Nested schemas in list items render correctly"
    - "Validation errors display with red border and error text"
  artifacts:
    - path: "apps/athanor_web/assets/js/app.js"
      provides: "Complete ConfigFormHook with list support and validation"
      contains: "addListItem"
  key_links:
    - from: "ConfigFormHook render"
      to: "ConfigFormHook state"
      via: "List item add/remove updates state and re-renders"
      pattern: "addListItem"
    - from: "ConfigFormHook validateAll"
      to: "Form submit handler"
      via: "Prevents submit if validation errors exist"
      pattern: "validateAll"
---

<objective>
Extend ConfigFormHook with list field rendering, collapsible items, reordering, and validation.

Purpose: Complete the client-side form management with support for dynamic list fields (the main reason for the client-side architecture) and inline validation for a polished user experience.

Output: Fully functional configuration forms with list add/remove/reorder, collapsible items, and validation feedback.
</objective>

<execution_context>
@/Users/binarymuse/.claude/get-shit-done/workflows/execute-plan.md
@/Users/binarymuse/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-configuration-forms-polish/05-CONTEXT.md
@.planning/phases/05-configuration-forms-polish/05-RESEARCH.md
@.planning/phases/05-configuration-forms-polish/05-02-SUMMARY.md

@apps/athanor_web/assets/js/app.js
@apps/substrate_shift/lib/substrate_shift.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add list field rendering with add/remove and collapsible items</name>
  <files>apps/athanor_web/assets/js/app.js</files>
  <action>
Extend ConfigFormHook to fully render list fields instead of placeholders.

1. Replace `createListPlaceholder` with `renderListField`:
   ```javascript
   renderListField(name, definition, path) {
     const container = document.createElement("div")
     container.className = "border border-base-300 rounded-lg p-4 mb-4"
     container.dataset.listContainer = JSON.stringify(path)

     // Header with label and add button
     const header = document.createElement("div")
     header.className = "flex items-center justify-between mb-4"

     const label = document.createElement("span")
     label.className = "font-semibold"
     label.textContent = definition.label || this.humanize(name)
     header.appendChild(label)

     const addBtn = document.createElement("button")
     addBtn.type = "button"
     addBtn.className = "btn btn-sm btn-outline"
     addBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-4"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" /></svg> Add`
     addBtn.dataset.addListItem = JSON.stringify(path)
     header.appendChild(addBtn)

     container.appendChild(header)

     if (definition.description) {
       const desc = document.createElement("p")
       desc.className = "text-sm text-base-content/60 mb-3"
       desc.textContent = definition.description
       container.appendChild(desc)
     }

     // Items container
     const itemsContainer = document.createElement("div")
     itemsContainer.className = "space-y-3"
     itemsContainer.dataset.itemsContainer = JSON.stringify(path)

     const items = this.getStateValue(path) || []
     items.forEach((item, index) => {
       itemsContainer.appendChild(this.renderListItem(definition.item_schema, path, index, items.length))
     })

     if (items.length === 0) {
       const empty = document.createElement("p")
       empty.className = "text-sm text-base-content/60 text-center py-4"
       empty.textContent = "No items yet. Click \"Add\" to add one."
       itemsContainer.appendChild(empty)
     }

     container.appendChild(itemsContainer)
     return container
   }
   ```

2. Add `renderListItem` for collapsible item cards:
   ```javascript
   renderListItem(itemSchema, listPath, index, totalItems) {
     const itemPath = [...listPath, index]

     const card = document.createElement("div")
     card.className = "card bg-base-200"
     card.dataset.itemCard = JSON.stringify(itemPath)

     const body = document.createElement("div")
     body.className = "card-body p-3 gap-2"

     // Header row with toggle, reorder, and remove buttons
     const headerRow = document.createElement("div")
     headerRow.className = "flex items-center gap-2"

     // Toggle button with summary
     const toggleBtn = document.createElement("button")
     toggleBtn.type = "button"
     toggleBtn.className = "flex-1 text-left text-sm font-medium flex items-center gap-2"
     toggleBtn.dataset.toggleItem = JSON.stringify(itemPath)

     const chevron = document.createElement("span")
     chevron.className = "text-base-content/40 text-xs transition-transform"
     chevron.dataset.chevron = "true"
     chevron.textContent = "▼"
     toggleBtn.appendChild(chevron)

     const summary = document.createElement("span")
     summary.textContent = `Item ${index + 1}`
     toggleBtn.appendChild(summary)

     headerRow.appendChild(toggleBtn)

     // Reorder buttons
     const reorderGroup = document.createElement("div")
     reorderGroup.className = "flex gap-1"

     const upBtn = document.createElement("button")
     upBtn.type = "button"
     upBtn.className = "btn btn-ghost btn-xs"
     upBtn.disabled = index === 0
     upBtn.innerHTML = "↑"
     upBtn.dataset.moveItem = JSON.stringify({path: listPath, index, direction: "up"})
     reorderGroup.appendChild(upBtn)

     const downBtn = document.createElement("button")
     downBtn.type = "button"
     downBtn.className = "btn btn-ghost btn-xs"
     downBtn.disabled = index === totalItems - 1
     downBtn.innerHTML = "↓"
     downBtn.dataset.moveItem = JSON.stringify({path: listPath, index, direction: "down"})
     reorderGroup.appendChild(downBtn)

     headerRow.appendChild(reorderGroup)

     // Remove button
     const removeBtn = document.createElement("button")
     removeBtn.type = "button"
     removeBtn.className = "btn btn-ghost btn-xs"
     removeBtn.innerHTML = "✕"
     removeBtn.dataset.removeListItem = JSON.stringify({path: listPath, index})
     headerRow.appendChild(removeBtn)

     body.appendChild(headerRow)

     // Detail section (collapsible)
     const detail = document.createElement("div")
     detail.className = "space-y-2 pl-6 mt-2"
     detail.dataset.itemDetail = "true"

     // Render item schema fields
     this.renderItemFields(detail, itemSchema.properties, itemPath)

     body.appendChild(detail)
     card.appendChild(body)

     return card
   }

   renderItemFields(parent, properties, basePath) {
     for (const {name, definition} of properties) {
       const fieldPath = [...basePath, name]
       const value = this.getStateValue(fieldPath)

       if (definition.type === "list") {
         // Nested list - recursive
         parent.appendChild(this.renderListField(name, definition, fieldPath))
       } else if (definition.type === "group") {
         parent.appendChild(this.renderGroup(name, definition, fieldPath))
       } else {
         parent.appendChild(this.renderScalarField(name, definition, fieldPath, value))
       }
     }
   }
   ```

3. Update `renderProperties` to call `renderListField` instead of placeholder:
   ```javascript
   renderProperties(parent, properties, path) {
     for (const {name, definition} of properties) {
       const fieldPath = [...path, name]
       const value = this.getStateValue(fieldPath)

       if (definition.type === "list") {
         parent.appendChild(this.renderListField(name, definition, fieldPath))
       } else if (definition.type === "group") {
         parent.appendChild(this.renderGroup(name, definition, fieldPath))
       } else {
         parent.appendChild(this.renderScalarField(name, definition, fieldPath, value))
       }
     }
   }
   ```
   (Delete `createListPlaceholder` function.)

4. Add event handlers in `bindEvents`:
   ```javascript
   // Add list item
   this.el.addEventListener("click", (e) => {
     const addBtn = e.target.closest("[data-add-list-item]")
     if (addBtn) {
       e.preventDefault()
       const path = JSON.parse(addBtn.dataset.addListItem)
       this.addListItem(path)
     }

     const removeBtn = e.target.closest("[data-remove-list-item]")
     if (removeBtn) {
       e.preventDefault()
       const {path, index} = JSON.parse(removeBtn.dataset.removeListItem)
       this.removeListItem(path, index)
     }

     const moveBtn = e.target.closest("[data-move-item]")
     if (moveBtn) {
       e.preventDefault()
       const {path, index, direction} = JSON.parse(moveBtn.dataset.moveItem)
       this.moveListItem(path, index, direction)
     }

     const toggleBtn = e.target.closest("[data-toggle-item]")
     if (toggleBtn) {
       e.preventDefault()
       this.toggleItemCollapse(toggleBtn)
     }
   })
   ```

5. Add list manipulation methods:
   ```javascript
   addListItem(path) {
     const list = this.getStateValue(path)
     const definition = this.getDefinitionForPath(path)
     const newItem = this.initStateFromSchema(definition.item_schema)
     list.push(newItem)
     this.render()
   }

   removeListItem(path, index) {
     const list = this.getStateValue(path)
     list.splice(index, 1)
     this.render()
   }

   moveListItem(path, index, direction) {
     const list = this.getStateValue(path)
     const newIndex = direction === "up" ? index - 1 : index + 1
     if (newIndex < 0 || newIndex >= list.length) return
     const [item] = list.splice(index, 1)
     list.splice(newIndex, 0, item)
     this.render()
   }

   toggleItemCollapse(toggleBtn) {
     const itemCard = toggleBtn.closest("[data-item-card]")
     const detail = itemCard.querySelector("[data-item-detail]")
     const chevron = toggleBtn.querySelector("[data-chevron]")

     detail.classList.toggle("hidden")
     chevron.textContent = detail.classList.contains("hidden") ? "▶" : "▼"
   }

   getDefinitionForPath(path) {
     let schema = this.schema
     for (const key of path) {
       if (typeof key === "number") {
         // Inside a list, schema stays at item_schema level
         continue
       }
       const prop = schema.properties.find(p => p.name === key)
       if (prop.definition.type === "list") {
         schema = prop.definition.item_schema
       } else if (prop.definition.type === "group") {
         schema = prop.definition.sub_schema
       } else {
         return prop.definition
       }
     }
     // Return the list definition from parent
     const parentPath = path.slice(0, -1)
     let parentSchema = this.schema
     for (const key of parentPath) {
       if (typeof key === "number") continue
       const prop = parentSchema.properties.find(p => p.name === key)
       if (prop.definition.type === "list") {
         parentSchema = prop.definition.item_schema
       } else if (prop.definition.type === "group") {
         parentSchema = prop.definition.sub_schema
       }
     }
     const lastKey = path[path.length - 1]
     const finalProp = parentSchema.properties.find(p => p.name === lastKey)
     return finalProp?.definition
   }
   ```
  </action>
  <verify>
1. Run `mix phx.server`
2. Navigate to `/experiments/new`, select SubstrateShift
3. Click "Add" on Model Pairs list - item should appear
4. Fill in item fields - values should update
5. Click collapse toggle - item should collapse to summary line
6. Add multiple items, use up/down buttons - order should change
7. Click remove - item should be deleted
8. Submit form - all list items should be in saved configuration
  </verify>
  <done>
List fields render with add button, items render with collapsible cards, up/down reordering works, remove deletes items, nested schemas render recursively.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add blur-tracked validation with inline error display</name>
  <files>apps/athanor_web/assets/js/app.js</files>
  <action>
Add validation to ConfigFormHook with blur tracking and inline error display.

1. Add `touched` Set in `mounted`:
   ```javascript
   mounted() {
     this.schema = JSON.parse(this.el.dataset.schema)
     this.state = this.initStateFromSchema(this.schema)
     this.touched = new Set()
     this.errors = new Map()  // path -> error message
     this.render()
     this.bindEvents()
   }
   ```

2. Add blur listener in `bindEvents`:
   ```javascript
   // Track blur for validation
   this.el.addEventListener("blur", (e) => {
     if (e.target.dataset.fieldPath) {
       const path = e.target.dataset.fieldPath
       this.touched.add(path)
       this.validateField(path)
       this.renderFieldError(path)
     }
   }, true)  // capture phase for blur
   ```

3. Update form submit handler to validate all fields:
   ```javascript
   form.addEventListener("submit", (e) => {
     // Mark all fields as touched
     this.touchAllFields()

     // Validate all
     this.validateAll()

     // If errors, prevent submit and show all errors
     if (this.errors.size > 0) {
       e.preventDefault()
       this.renderAllErrors()
       // Scroll to first error
       const firstError = this.el.querySelector(".input-error, .select-error, .textarea-error")
       if (firstError) firstError.scrollIntoView({behavior: "smooth", block: "center"})
       return
     }

     const hiddenInput = document.getElementById("config-json-input")
     if (hiddenInput) hiddenInput.value = JSON.stringify(this.state)
   })
   ```

4. Add validation methods:
   ```javascript
   validateField(pathJson) {
     const path = JSON.parse(pathJson)
     const value = this.getStateValue(path)
     const definition = this.getFieldDefinition(path)

     if (!definition) return

     // Required check
     if (definition.required && (value === null || value === undefined || value === "")) {
       this.errors.set(pathJson, "This field is required")
       return
     }

     // Min/max for numbers
     if ((definition.type === "integer" || definition.type === "number") && value !== null && value !== "") {
       const num = Number(value)
       if (definition.min !== undefined && num < definition.min) {
         this.errors.set(pathJson, `Minimum value is ${definition.min}`)
         return
       }
       if (definition.max !== undefined && num > definition.max) {
         this.errors.set(pathJson, `Maximum value is ${definition.max}`)
         return
       }
     }

     // Enum options check
     if (definition.type === "enum" && definition.options && value) {
       if (!definition.options.includes(value)) {
         this.errors.set(pathJson, "Please select a valid option")
         return
       }
     }

     // Clear error if valid
     this.errors.delete(pathJson)
   }

   getFieldDefinition(path) {
     let schema = this.schema
     for (let i = 0; i < path.length; i++) {
       const key = path[i]
       if (typeof key === "number") {
         // Skip numeric indices, we're already at item_schema level
         continue
       }
       const prop = schema.properties.find(p => p.name === key)
       if (!prop) return null

       if (i === path.length - 1) {
         return prop.definition
       }

       if (prop.definition.type === "list") {
         schema = prop.definition.item_schema
       } else if (prop.definition.type === "group") {
         schema = prop.definition.sub_schema
       }
     }
     return null
   }

   validateAll() {
     this.errors.clear()
     this.validateSchemaFields(this.schema, [])
   }

   validateSchemaFields(schema, basePath) {
     for (const {name, definition} of schema.properties) {
       const path = [...basePath, name]

       if (definition.type === "list") {
         const items = this.getStateValue(path) || []
         items.forEach((_, index) => {
           this.validateSchemaFields(definition.item_schema, [...path, index])
         })
       } else if (definition.type === "group") {
         this.validateSchemaFields(definition.sub_schema, path)
       } else {
         const pathJson = JSON.stringify(path)
         this.validateField(pathJson)
       }
     }
   }

   touchAllFields() {
     this.touchSchemaFields(this.schema, [])
   }

   touchSchemaFields(schema, basePath) {
     for (const {name, definition} of schema.properties) {
       const path = [...basePath, name]

       if (definition.type === "list") {
         const items = this.getStateValue(path) || []
         items.forEach((_, index) => {
           this.touchSchemaFields(definition.item_schema, [...path, index])
         })
       } else if (definition.type === "group") {
         this.touchSchemaFields(definition.sub_schema, path)
       } else {
         this.touched.add(JSON.stringify(path))
       }
     }
   }
   ```

5. Add error rendering:
   ```javascript
   renderFieldError(pathJson) {
     const input = this.el.querySelector(`[data-field-path='${pathJson}']`)
     if (!input) return

     const wrapper = input.closest(".fieldset")
     if (!wrapper) return

     // Remove existing error
     const existingError = wrapper.querySelector(".field-error")
     if (existingError) existingError.remove()

     // Remove error styling from input
     input.classList.remove("input-error", "select-error", "textarea-error", "checkbox-error")

     // If touched and has error, show it
     if (this.touched.has(pathJson) && this.errors.has(pathJson)) {
       const errorClass = input.tagName === "SELECT" ? "select-error"
         : input.tagName === "TEXTAREA" ? "textarea-error"
         : input.type === "checkbox" ? "checkbox-error"
         : "input-error"
       input.classList.add(errorClass)

       const errorEl = document.createElement("p")
       errorEl.className = "field-error mt-1 flex gap-2 items-center text-sm text-error"
       errorEl.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-5"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z" /></svg><span>${this.errors.get(pathJson)}</span>`
       wrapper.appendChild(errorEl)
     }
   }

   renderAllErrors() {
     for (const [pathJson] of this.errors) {
       this.renderFieldError(pathJson)
     }
   }
   ```

6. Reset touched and errors on schema change:
   ```javascript
   handleEvent(event, payload) {
     if (event === "config_schema_changed") {
       this.schema = JSON.parse(payload.schema_json)
       this.state = this.initStateFromSchema(this.schema)
       this.touched = new Set()
       this.errors = new Map()
       this.render()
     }
   }
   ```

7. Update `renderScalarField` to include required asterisk (already done in Plan 02) and ensure error container is ready:
   The wrapper div already has the structure. The `renderFieldError` will append the error element.
  </action>
  <verify>
1. Run `mix phx.server`
2. Navigate to `/experiments/new`, select SubstrateShift
3. Click into a required field, then blur without entering value - error should appear
4. Enter valid value, blur - error should clear
5. Enter a number outside min/max range - error should appear
6. Try to submit with validation errors - form should not submit, errors shown, scroll to first error
7. Fix all errors, submit - form should submit successfully
  </verify>
  <done>
Validation tracks touched fields via blur events, shows inline errors with red border and error text, validates required/min/max/enum constraints, prevents form submit if errors exist, clears errors when field becomes valid.
  </done>
</task>

</tasks>

<verification>
1. List fields render with add/remove buttons
2. List items are collapsible mini-cards
3. Up/down reorder buttons work correctly
4. Nested schemas in list items render properly
5. Required field validation shows error on blur
6. Min/max validation for integers works
7. Errors display with red border + text below field
8. Form submit is blocked when validation errors exist
9. Errors clear when field becomes valid
10. Complete form submission works with lists and validation
</verification>

<success_criteria>
- List fields have working add/remove functionality
- List items collapse to summary line and expand to show fields
- Up/down buttons reorder items within list
- Nested list items render correctly (recursive)
- Required field validation triggers on blur
- Min/max constraints are validated
- Errors display inline with red border and icon+text
- Form submission blocked when errors exist
- Form submission succeeds with valid data including lists
</success_criteria>

<output>
After completion, create `.planning/phases/05-configuration-forms-polish/05-03-SUMMARY.md`
</output>
