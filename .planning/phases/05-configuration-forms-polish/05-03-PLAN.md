---
phase: 05-configuration-forms-polish
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex
  - apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex
  - apps/athanor/lib/experiment/config_schema.ex
autonomous: true

must_haves:
  truths:
    - "List fields render with inline items stacked vertically"
    - "Each list item appears in a collapsible mini-card"
    - "Collapsed items show 'Item N' summary"
    - "Add button appends new item to list"
    - "Remove button deletes item from list"
    - "Up/down buttons reorder list items"
    - "Validation errors appear inline below fields with red border"
    - "Errors clear when field is fixed and blurred"
    - "Required field validation triggers on blur"
    - "Form validates all fields on submit"
    - "Unlimited nesting depth with visual indentation"
  artifacts:
    - path: "apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex"
      provides: "Complete config_list_field/1 with collapsible items, reordering, and recursive nesting"
      contains: "config_list_field"
    - path: "apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex"
      provides: "Validation event handlers, list reorder handlers, and build_config_values/2"
      contains: "move_list_item"
    - path: "apps/athanor/lib/experiment/config_schema.ex"
      provides: "validate/2 function for config validation"
      contains: "def validate"
  key_links:
    - from: "apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex"
      to: "apps/athanor/lib/experiment/config_schema.ex"
      via: "ConfigSchema.validate/2 call"
      pattern: "ConfigSchema\\.validate"
    - from: "apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex"
      to: "Phoenix.LiveView.JS"
      via: "JS.toggle_class for collapse"
      pattern: "JS\\.toggle_class"
    - from: "list_item component"
      to: "render_field/1 dispatch"
      via: "Recursive dispatch for nested groups/lists"
      pattern: "render_field.*field_def\\.type"
---

<objective>
Complete list field rendering with collapsible items, reordering, and implement blur-based validation.

Purpose: Lists are the most complex field type with nested schemas, and validation is required for proper UX. This completes the ConfigFormComponent and enables full form functionality.

Output: Fully functional configuration forms with list management and inline validation.
</objective>

<execution_context>
@/Users/binarymuse/.claude/get-shit-done/workflows/execute-plan.md
@/Users/binarymuse/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-configuration-forms-polish/05-CONTEXT.md
@.planning/phases/05-configuration-forms-polish/05-RESEARCH.md
@.planning/phases/05-configuration-forms-polish/05-01-SUMMARY.md
@.planning/phases/05-configuration-forms-polish/05-02-SUMMARY.md

@apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex
@apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex
@apps/athanor/lib/experiment/config_schema.ex
@apps/athanor_web/lib/athanor_web/live/experiments/components/results_panel.ex
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ConfigSchema.validate/2 function with proper error flattening</name>
  <files>apps/athanor/lib/experiment/config_schema.ex</files>
  <action>
Add a validation function to ConfigSchema that validates a config map against the schema.

1. Add validate/2 function:
   ```elixir
   @doc """
   Validates a configuration map against a schema.
   Returns %{path_key => error_message} for any validation failures.
   Only validates fields that are in the touched set (if provided).
   """
   def validate(%__MODULE__{} = schema, config, touched \\ nil) do
     schema.properties
     |> Enum.reduce(%{}, fn {name, field_def}, errors ->
       path_key = to_string(name)
       value = Map.get(config, to_string(name)) || Map.get(config, name)

       # Skip if touched set provided and this field not touched
       if touched && not MapSet.member?(touched, path_key) do
         errors
       else
         case validate_field(field_def, value, path_key) do
           nil -> errors
           error when is_binary(error) -> Map.put(errors, path_key, error)
           # CRITICAL: When validate_field returns a map (for :list/:group),
           # merge it into the errors map instead of nesting it
           error when is_map(error) -> Map.merge(errors, error)
         end
       end
     end)
   end
   ```

2. Add validate_field/3 helper with pattern matching:
   ```elixir
   defp validate_field(%{required: true}, nil, _path), do: "is required"
   defp validate_field(%{required: true}, "", _path), do: "is required"

   defp validate_field(%{type: :integer, min: min}, value, _path)
        when is_integer(value) and not is_nil(min) and value < min,
        do: "must be at least #{min}"

   defp validate_field(%{type: :integer, max: max}, value, _path)
        when is_integer(value) and not is_nil(max) and value > max,
        do: "must be at most #{max}"

   defp validate_field(%{type: :enum, options: options}, value, _path) when not is_nil(value) do
     value_atom = if is_binary(value), do: String.to_existing_atom(value), else: value
     if value_atom in options, do: nil, else: "must be one of: #{Enum.join(options, ", ")}"
   rescue
     ArgumentError -> "must be one of: #{Enum.join(options, ", ")}"
   end

   # CRITICAL: :list validation returns a FLAT map with dotted path keys
   defp validate_field(%{type: :list, item_schema: item_schema}, items, path_key)
        when is_list(items) do
     items
     |> Enum.with_index()
     |> Enum.reduce(%{}, fn {item, idx}, acc ->
       item_path = "#{path_key}.#{idx}"
       item_errors = validate(item_schema, item)
       # Prefix each item error with the item path
       Enum.reduce(item_errors, acc, fn {field, error}, acc2 ->
         Map.put(acc2, "#{item_path}.#{field}", error)
       end)
     end)
     |> case do
       errors when map_size(errors) == 0 -> nil
       errors -> errors  # Return the map directly, validate/2 will merge it
     end
   end

   # CRITICAL: :group validation returns a FLAT map with dotted path keys
   defp validate_field(%{type: :group, sub_schema: sub_schema}, values, path_key)
        when is_map(values) do
     sub_errors = validate(sub_schema, values)
     Enum.reduce(sub_errors, %{}, fn {field, error}, acc ->
       Map.put(acc, "#{path_key}.#{field}", error)
     end)
     |> case do
       errors when map_size(errors) == 0 -> nil
       errors -> errors  # Return the map directly, validate/2 will merge it
     end
   end

   defp validate_field(_field_def, _value, _path), do: nil
   ```

3. The key fix: When `validate_field` returns a map (for :list/:group types), use `Map.merge(errors, returned_map)` in the main `validate/2` function, NOT `Map.put`. This ensures errors like `"model_pairs.0.model_a"` appear at the top level of the errors map, not nested under `"model_pairs"`.
  </action>
  <verify>
Run in iex:
```elixir
schema = SubstrateShift.config()
ConfigSchema.validate(schema, %{})  # Returns errors for required fields
ConfigSchema.validate(schema, %{"runs_per_pair" => 5})  # No error for runs_per_pair
ConfigSchema.validate(schema, %{"runs_per_pair" => 0}, MapSet.new(["runs_per_pair"]))  # min violation

# Test list validation returns flat keys:
list_errors = ConfigSchema.validate(schema, %{"model_pairs" => [%{}]})
# Should contain "model_pairs.0.model_a" => "is required", NOT nested
Map.has_key?(list_errors, "model_pairs.0.model_a")  # => true
```
  </verify>
  <done>
ConfigSchema.validate/2,3 validates configs against schemas with support for required, min/max, enum options, and nested list/group validation. Returns flat error map with dotted path keys (e.g., "model_pairs.0.model_a" not nested under "model_pairs").
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement config_list_field with collapsible items, reordering, and recursive field dispatch</name>
  <files>apps/athanor_web/lib/athanor_web/live/experiments/components/config_form_component.ex</files>
  <action>
Replace the list field stub with full implementation including collapsible mini-cards, reorder buttons, and **recursive dispatch for unlimited nesting**.

1. Implement config_list_field/1 (replace the stub from Plan 02):
   ```heex
   defp config_list_field(assigns) do
     # Extract items from values map using path
     path_key = path_to_key(assigns.path)
     items = Map.get(assigns.values, path_key, [])
     assigns = assign(assigns, :items, items)
     assigns = assign(assigns, :path_key, path_key)

     ~H"""
     <div class="card bg-base-200 mb-4">
       <div class="card-body gap-3 p-4">
         <div class="flex items-center justify-between">
           <div>
             <h4 class="card-title text-base">{@field_def[:label] || humanize(@name)}</h4>
             <p :if={@field_def[:description]} class="text-xs text-base-content/60">
               {@field_def.description}
             </p>
           </div>
           <button
             type="button"
             phx-click="add_list_item"
             phx-value-path={@path_key}
             class="btn btn-sm btn-outline"
           >
             <.icon name="hero-plus" class="size-4" /> Add
           </button>
         </div>

         <div :if={@items == []} class="text-sm text-base-content/60 text-center py-4">
           No items yet. Click "Add" to create one.
         </div>

         <div class="space-y-3">
           <.list_item
             :for={{item, idx} <- Enum.with_index(@items)}
             item={item}
             index={idx}
             item_count={length(@items)}
             path_key={@path_key}
             item_schema={@field_def.item_schema}
             errors={@errors}
             touched={@touched}
           />
         </div>
       </div>
     </div>
     """
   end
   ```

2. Implement list_item/1 component with collapsible card and **recursive field dispatch**:
   - Use JS.toggle_class pattern from results_panel.ex
   - Summary shows "Item {idx + 1}" when collapsed
   - Detail shows nested fields when expanded
   - Include up/down/remove buttons in header row
   - **CRITICAL: Use render_field/1 dispatch instead of config_scalar_field for unlimited nesting**

   ```heex
   defp list_item(assigns) do
     ~H"""
     <div class="card bg-base-300" id={"list-item-#{@path_key}-#{@index}"}>
       <div class="card-body p-3 gap-2">
         <%!-- Header with collapse toggle, reorder, remove --%>
         <div class="flex items-center gap-2">
           <button
             type="button"
             class="flex-1 text-left text-sm font-medium flex items-center gap-2"
             phx-click={
               JS.toggle_class("hidden", to: "#item-summary-#{@path_key}-#{@index}")
               |> JS.toggle_class("hidden", to: "#item-detail-#{@path_key}-#{@index}")
               |> JS.toggle_class("rotate-90", to: "#item-chevron-#{@path_key}-#{@index}")
             }
           >
             <span id={"item-chevron-#{@path_key}-#{@index}"} class="transition-transform rotate-90">
               <.icon name="hero-chevron-right" class="size-4" />
             </span>
             <span id={"item-summary-#{@path_key}-#{@index}"} class="hidden text-base-content/70">
               Item {@index + 1}
             </span>
             <span id={"item-detail-label-#{@path_key}-#{@index}"}>
               Item {@index + 1}
             </span>
           </button>

           <%!-- Reorder buttons --%>
           <button
             :if={@index > 0}
             type="button"
             phx-click="move_list_item_up"
             phx-value-path={@path_key}
             phx-value-index={@index}
             class="btn btn-ghost btn-xs"
             title="Move up"
           >
             <.icon name="hero-chevron-up" class="size-4" />
           </button>
           <button
             :if={@index < @item_count - 1}
             type="button"
             phx-click="move_list_item_down"
             phx-value-path={@path_key}
             phx-value-index={@index}
             class="btn btn-ghost btn-xs"
             title="Move down"
           >
             <.icon name="hero-chevron-down" class="size-4" />
           </button>

           <button
             type="button"
             phx-click="remove_list_item"
             phx-value-path={@path_key}
             phx-value-index={@index}
             class="btn btn-ghost btn-xs text-error"
             title="Remove"
           >
             <.icon name="hero-x-mark" class="size-4" />
           </button>
         </div>

         <%!-- Expandable detail with nested fields using RECURSIVE dispatch --%>
         <div id={"item-detail-#{@path_key}-#{@index}"} class="pl-6 space-y-3">
           <%!-- CRITICAL: item_schema.properties is a list of tuples --%>
           <%!-- CRITICAL: Use render_field/1 for unlimited nesting (handles :group, :list, scalars) --%>
           <%= for {field_name, field_def} <- @item_schema.properties do %>
             <.render_field
               name={field_name}
               field_def={field_def}
               path={[@path_key, @index, field_name]}
               value={Map.get(@item, to_string(field_name)) || Map.get(@item, field_name)}
               values={@item}
               errors={@errors}
               touched={@touched}
             />
           <% end %>
         </div>
       </div>
     </div>
     """
   end
   ```

3. **CRITICAL: Add render_field/1 dispatch function for unlimited nesting:**
   This is the key to supporting nested :group and :list within list items per user decision "Unlimited nesting depth with visual indentation."
   ```elixir
   # Dispatch function that routes to appropriate renderer based on field type
   # This enables unlimited nesting - list items can contain groups or nested lists
   defp render_field(assigns) do
     ~H"""
     <%= case @field_def.type do %>
       <% :group -> %>
         <%!-- Nested group within list item - render with visual indentation --%>
         <div class="border-l-2 border-base-content/10 pl-3">
           <.config_group
             name={@name}
             field_def={@field_def}
             path={@path}
             values={@values}
             errors={@errors}
             touched={@touched}
           />
         </div>
       <% :list -> %>
         <%!-- Nested list within list item - recursive structure --%>
         <div class="border-l-2 border-base-content/10 pl-3">
           <.config_list_field
             name={@name}
             field_def={@field_def}
             path={@path}
             values={@values}
             errors={@errors}
             touched={@touched}
           />
         </div>
       <% _ -> %>
         <%!-- Scalar field (string, integer, boolean, enum) --%>
         <.config_scalar_field
           name={@name}
           field_def={@field_def}
           path={@path}
           value={@value}
           errors={@errors}
           touched={@touched}
         />
     <% end %>
     """
   end
   ```

4. Update config_scalar_field to accept value directly (for list item context):
   - Add `attr :value, :any, default: nil`
   - Use passed value or look up from values map by path
  </action>
  <verify>
Run `mix compile` - no errors.
Component includes config_list_field/1, list_item/1, and render_field/1 functions.
  </verify>
  <done>
config_list_field/1 renders lists with collapsible mini-cards. Each item has up/down/remove buttons. Nested fields render via render_field/1 dispatch which supports :group, :list, and scalar types for unlimited nesting depth. JS.toggle_class handles collapse state. Item schema properties iterated as list of tuples.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire validation and reorder events in InstanceLive.New</name>
  <files>apps/athanor_web/lib/athanor_web/live/experiments/instance_live/new.ex</files>
  <action>
Complete the validation wiring and add list reorder event handlers.

1. **CRITICAL: Define `build_config_values/2` function:**
   This function merges raw form params with list_items to create a complete config map suitable for validation and display.
   ```elixir
   defp build_config_values(config_params, list_items) do
     # Start with raw params (scalar values)
     base = config_params || %{}

     # Merge in list items (replace indexed-map representations with actual lists)
     Enum.reduce(list_items, base, fn {path_key, items}, acc ->
       # Convert list items to the format expected by validation
       Map.put(acc, path_key, items)
     end)
   end
   ```

2. Update handle_event("validate", ...) for blur-based validation:
   ```elixir
   def handle_event("validate", %{"instance" => params, "_target" => target}, socket) do
     # Determine which config field was touched based on _target
     config_touched =
       case extract_config_path(target) do
         nil -> socket.assigns.config_touched
         path_key -> MapSet.put(socket.assigns.config_touched, path_key)
       end

     # Extract and store config values using the new build_config_values/2
     config_values = build_config_values(params["configuration"] || %{}, socket.assigns.list_items)

     # Run validation only on touched fields
     config_errors =
       if socket.assigns.config_schema do
         Athanor.Experiment.ConfigSchema.validate(
           socket.assigns.config_schema,
           config_values,
           config_touched
         )
       else
         %{}
       end

     # Continue with existing changeset validation for instance fields
     changeset =
       %Instance{}
       |> Instance.changeset(params)
       |> Map.put(:action, :validate)

     {:noreply,
      socket
      |> assign(:config_values, config_values)
      |> assign(:config_errors, config_errors)
      |> assign(:config_touched, config_touched)
      |> assign(:form, to_form(changeset))}
   end

   defp extract_config_path(["instance", "configuration" | rest]) do
     Enum.join(rest, ".")
   end
   defp extract_config_path(_), do: nil
   ```

3. Add phx-debounce="blur" to scalar field inputs in ConfigFormComponent:
   - Already using phx-change on form, debounce delays until blur
   - Add `phx-debounce="blur"` attribute to all input/textarea/select elements

4. Update handle_event("save", ...) to validate all fields:
   ```elixir
   def handle_event("save", %{"instance" => params}, socket) do
     # Mark all fields as touched for full validation
     all_touched = get_all_field_paths(socket.assigns.config_schema)

     # Use build_config_values/2 (same function as validate handler)
     config_values = build_config_values(params["configuration"] || %{}, socket.assigns.list_items)

     config_errors =
       if socket.assigns.config_schema do
         Athanor.Experiment.ConfigSchema.validate(socket.assigns.config_schema, config_values, all_touched)
       else
         %{}
       end

     if map_size(config_errors) > 0 do
       {:noreply,
        socket
        |> assign(:config_errors, config_errors)
        |> assign(:config_touched, all_touched)}
     else
       # Proceed with save (existing logic)
       # Use parse_configuration for final save format (existing function)
       config = parse_configuration(params["configuration"] || %{}, socket.assigns.list_items)
       # ... rest of existing save logic
     end
   end
   ```

5. Add list reorder handlers:
   ```elixir
   def handle_event("move_list_item_up", %{"path" => path_key, "index" => idx_str}, socket) do
     idx = String.to_integer(idx_str)
     list_items = swap_list_items(socket.assigns.list_items, path_key, idx, idx - 1)
     {:noreply, assign(socket, :list_items, list_items)}
   end

   def handle_event("move_list_item_down", %{"path" => path_key, "index" => idx_str}, socket) do
     idx = String.to_integer(idx_str)
     list_items = swap_list_items(socket.assigns.list_items, path_key, idx, idx + 1)
     {:noreply, assign(socket, :list_items, list_items)}
   end

   defp swap_list_items(list_items, path_key, from_idx, to_idx) do
     Map.update(list_items, path_key, [], fn items ->
       item = Enum.at(items, from_idx)
       items
       |> List.delete_at(from_idx)
       |> List.insert_at(to_idx, item)
     end)
   end
   ```

6. Remove old render_config_field and render_list_item_field defp functions (now handled by component)

7. Add helper to get all field paths for full validation:
   ```elixir
   defp get_all_field_paths(nil), do: MapSet.new()
   defp get_all_field_paths(schema) do
     # schema.properties is a list of {name, field_def} tuples
     schema.properties
     |> Enum.flat_map(fn {name, field_def} ->
       path = to_string(name)
       case field_def do
         %{type: :list} -> [path]  # List items validated separately
         %{type: :group, sub_schema: sub} ->
           # sub.properties is also a list of tuples
           Enum.map(sub.properties, fn {n, _} -> "#{path}.#{n}" end)
         _ -> [path]
       end
     end)
     |> MapSet.new()
   end
   ```
  </action>
  <verify>
1. Run `mix phx.server` and navigate to /experiments/new
2. Select SubstrateShift experiment
3. Clear the "Runs Per Pair" field, blur -> error appears "is required"
4. Enter "0", blur -> error "must be at least 1"
5. Enter "50", blur -> error clears
6. Add model pair items, reorder with up/down buttons
7. Submit form - validates all fields, shows errors if any
8. Fix errors and submit - instance creates successfully
  </verify>
  <done>
InstanceLive.New has blur-based validation using ConfigSchema.validate/2. build_config_values/2 merges form params with list_items for validation. List items can be reordered with up/down buttons. Form validates all fields on submit. All old render helpers removed. All property access uses list-of-tuples iteration.
  </done>
</task>

</tasks>

<verification>
1. `mix compile` succeeds with no warnings
2. ConfigSchema.validate/2 returns flat error map (e.g., "model_pairs.0.model_a" not nested)
3. Validation errors appear inline below fields with red border
4. Errors clear when field fixed and blurred
5. List items have collapse/expand toggle (chevron rotation)
6. List items can be reordered (up/down buttons work)
7. Add/remove list item buttons work
8. Form submit validates all fields and shows errors
9. Valid form submits successfully and creates instance
10. **If list item schema contains a :group or nested :list, it renders correctly via render_field/1 dispatch**
</verification>

<success_criteria>
- ConfigSchema.validate/2,3 validates configs against schema rules
- Nested list/group errors are MERGED into flat error map (not nested)
- build_config_values/2 defined and used by both validate and save handlers
- List fields render with collapsible mini-cards
- Each list item shows "Item N" summary when collapsed
- Up/down buttons reorder list items
- phx-debounce="blur" delays validation until field blur
- Touched state tracks which fields have been interacted with
- Inline errors display with red border and error text
- Errors clear when field is fixed and blurred
- Form submit validates all fields regardless of touched state
- Complete form workflow: fill, validate, fix errors, submit
- **Unlimited nesting depth: list items with :group or :list fields render via render_field/1 dispatch**
</success_criteria>

<output>
After completion, create `.planning/phases/05-configuration-forms-polish/05-03-SUMMARY.md`
</output>
